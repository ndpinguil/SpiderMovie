"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));
var import_dom_event_testing_library = require("dom-event-testing-library"), React = __toESM(require("react")), ReactDOM = __toESM(require("react-dom")), import_test_utils = require("react-dom/test-utils"), import_modality = require("../../modality/index"), import__ = __toESM(require("..")), import_jsx_runtime = require("react/jsx-runtime");
function createRoot(rootNode) {
  return {
    render(element) {
      ReactDOM.render(element, rootNode);
    }
  };
}
(0, import_dom_event_testing_library.describeWithPointerEvent)("useHover", (hasPointerEvents) => {
  let root, rootNode;
  beforeEach(() => {
    (0, import_dom_event_testing_library.setPointerEvent)(hasPointerEvents), rootNode = document.createElement("div"), document.body.appendChild(rootNode), root = createRoot(rootNode);
  }), afterEach(() => {
    root.render(null), document.body.removeChild(rootNode), rootNode = null, root = null, (0, import_modality.testOnly_resetActiveModality)(), (0, import_dom_event_testing_library.clearPointers)();
  }), describe("contain", () => {
    let onHoverChange, onHoverStart, onHoverUpdate, onHoverEnd, ref, childRef;
    const componentInit = () => {
      onHoverChange = jest.fn(), onHoverStart = jest.fn(), onHoverUpdate = jest.fn(), onHoverEnd = jest.fn(), ref = React.createRef(), childRef = React.createRef();
      const Component = () => ((0, import__.default)(ref, {
        onHoverChange,
        onHoverStart,
        onHoverUpdate,
        onHoverEnd
      }), (0, import__.default)(childRef, { contain: !0 }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref: childRef }) }));
      (0, import_test_utils.act)(() => {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("contains the hover gesture", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current), child = (0, import_dom_event_testing_library.createEventTarget)(childRef.current);
      (0, import_test_utils.act)(() => {
        target.pointerover(), target.pointerout(), child.pointerover();
      }), expect(onHoverEnd).toBeCalled(), (0, import_test_utils.act)(() => {
        child.pointerout();
      }), expect(onHoverStart).toBeCalled();
    });
  }), describe("disabled", () => {
    let onHoverChange, onHoverStart, onHoverUpdate, onHoverEnd, ref;
    const componentInit = () => {
      onHoverChange = jest.fn(), onHoverStart = jest.fn(), onHoverUpdate = jest.fn(), onHoverEnd = jest.fn(), ref = React.createRef();
      const Component = () => ((0, import__.default)(ref, {
        disabled: !0,
        onHoverChange,
        onHoverStart,
        onHoverUpdate,
        onHoverEnd
      }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref }));
      (0, import_test_utils.act)(() => {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("does not call callbacks", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerover(), target.pointerout();
      }), expect(onHoverChange).not.toBeCalled(), expect(onHoverStart).not.toBeCalled(), expect(onHoverUpdate).not.toBeCalled(), expect(onHoverEnd).not.toBeCalled();
    });
  }), describe("onHoverStart", () => {
    let onHoverStart, ref;
    const componentInit = () => {
      onHoverStart = jest.fn(), ref = React.createRef();
      const Component = () => ((0, import__.default)(ref, { onHoverStart }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref }));
      (0, import_test_utils.act)(() => {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("is called for mouse pointers", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerover({ pointerType: "mouse" });
      }), expect(onHoverStart).toBeCalledTimes(1);
    }), test("is not called for touch pointers", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerdown({ pointerType: "touch" }), target.pointerup({ pointerType: "touch" });
      }), expect(onHoverStart).not.toBeCalled();
    }), test("is called if a mouse pointer is used after a touch pointer", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerdown({ pointerType: "touch" }), target.pointerup({ pointerType: "touch" }), target.pointerover({ pointerType: "mouse" });
      }), expect(onHoverStart).toBeCalledTimes(1);
    });
  }), describe("onHoverChange", () => {
    let onHoverChange, ref;
    const componentInit = () => {
      onHoverChange = jest.fn(), ref = React.createRef();
      const Component = () => ((0, import__.default)(ref, { onHoverChange }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref }));
      (0, import_test_utils.act)(() => {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("is called for mouse pointers", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerover();
      }), expect(onHoverChange).toBeCalledTimes(1), expect(onHoverChange).toBeCalledWith(!0), (0, import_test_utils.act)(() => {
        target.pointerout();
      }), expect(onHoverChange).toBeCalledTimes(2), expect(onHoverChange).toBeCalledWith(!1);
    }), test("is not called for touch pointers", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerdown({ pointerType: "touch" }), target.pointerup({ pointerType: "touch" });
      }), expect(onHoverChange).not.toBeCalled();
    });
  }), describe("onHoverEnd", () => {
    let onHoverEnd, ref, childRef;
    const componentInit = () => {
      onHoverEnd = jest.fn(), ref = React.createRef(), childRef = React.createRef();
      const Component = () => ((0, import__.default)(ref, { onHoverEnd }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref: childRef }) }));
      (0, import_test_utils.act)(() => {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("is called for mouse pointers", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerover(), target.pointerout();
      }), expect(onHoverEnd).toBeCalledTimes(1);
    }), test("is not called for touch pointers", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerdown({ pointerType: "touch" }), target.pointerup({ pointerType: "touch" });
      }), expect(onHoverEnd).not.toBeCalled();
    }), test("is not called when entering children of the target", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current), child = (0, import_dom_event_testing_library.createEventTarget)(childRef.current);
      (0, import_test_utils.act)(() => {
        target.pointerover(), target.pointerout({ relatedTarget: childRef.current }), child.pointerover({ relatedTarget: target.node });
      }), expect(onHoverEnd).not.toBeCalled();
    });
  }), describe("onHoverUpdate", () => {
    test('is called after the active pointer moves"', () => {
      const onHoverUpdate = jest.fn(), ref = React.createRef(), Component = () => ((0, import__.default)(ref, { onHoverUpdate }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref }));
      (0, import_test_utils.act)(() => {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerover(), target.pointerhover({ x: 0, y: 0 }), target.pointerhover({ x: 1, y: 1 });
      }), expect(onHoverUpdate).toBeCalledTimes(2);
    });
  }), describe("repeat use", () => {
    let onHoverChange, onHoverStart, onHoverUpdate, onHoverEnd, ref;
    const componentInit = () => {
      onHoverChange = jest.fn(), onHoverStart = jest.fn(), onHoverUpdate = jest.fn(), onHoverEnd = jest.fn(), ref = React.createRef();
      const Component = () => ((0, import__.default)(ref, {
        onHoverChange,
        onHoverStart,
        onHoverUpdate,
        onHoverEnd
      }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref }));
      (0, import_test_utils.act)(() => {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("callbacks are called each time", () => {
      componentInit();
      const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(() => {
        target.pointerover(), target.pointerhover({ x: 1, y: 1 }), target.pointerout();
      }), expect(onHoverStart).toBeCalledTimes(1), expect(onHoverUpdate).toBeCalledTimes(1), expect(onHoverEnd).toBeCalledTimes(1), expect(onHoverChange).toBeCalledTimes(2), (0, import_test_utils.act)(() => {
        target.pointerover(), target.pointerhover({ x: 1, y: 1 }), target.pointerout();
      }), expect(onHoverStart).toBeCalledTimes(2), expect(onHoverUpdate).toBeCalledTimes(2), expect(onHoverEnd).toBeCalledTimes(2), expect(onHoverChange).toBeCalledTimes(4);
    });
  });
});
//# sourceMappingURL=index-test.js.map
