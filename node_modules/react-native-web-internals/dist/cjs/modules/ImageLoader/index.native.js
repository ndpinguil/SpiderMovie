"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var ImageLoader_exports = {};
__export(ImageLoader_exports, {
  ImageUriCache: () => ImageUriCache,
  default: () => ImageLoader_default
});
module.exports = __toCommonJS(ImageLoader_exports);
const dataUriPattern = /^data:/, _ImageUriCache = class _ImageUriCache {
  static has(uri) {
    const entries = _ImageUriCache._entries;
    return dataUriPattern.test(uri) || !!entries[uri];
  }
  static add(uri) {
    const entries = _ImageUriCache._entries, lastUsedTimestamp = Date.now();
    entries[uri] ? (entries[uri].lastUsedTimestamp = lastUsedTimestamp, entries[uri].refCount += 1) : entries[uri] = {
      lastUsedTimestamp,
      refCount: 1
    };
  }
  static remove(uri) {
    const entries = _ImageUriCache._entries;
    entries[uri] && (entries[uri].refCount -= 1), _ImageUriCache._cleanUpIfNeeded();
  }
  static _cleanUpIfNeeded() {
    const entries = _ImageUriCache._entries, imageUris = Object.keys(entries);
    if (imageUris.length + 1 > _ImageUriCache._maximumEntries) {
      let leastRecentlyUsedKey, leastRecentlyUsedEntry;
      imageUris.forEach((uri) => {
        const entry = entries[uri];
        (!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0 && (leastRecentlyUsedKey = uri, leastRecentlyUsedEntry = entry);
      }), leastRecentlyUsedKey && delete entries[leastRecentlyUsedKey];
    }
  }
};
_ImageUriCache._maximumEntries = 256, _ImageUriCache._entries = {};
let ImageUriCache = _ImageUriCache, id = 0;
const requests = {}, ImageLoader = {
  abort(requestId) {
    let image = requests[`${requestId}`];
    image && (image.onerror = null, image.onload = null, image = null, delete requests[`${requestId}`]);
  },
  getSize(uri, success, failure) {
    let complete = !1;
    const interval = setInterval(callback, 16), requestId = ImageLoader.load(uri, callback, errorCallback);
    function callback() {
      const image = requests[`${requestId}`];
      if (image) {
        const { naturalHeight, naturalWidth } = image;
        naturalHeight && naturalWidth && (success(naturalWidth, naturalHeight), complete = !0);
      }
      complete && (ImageLoader.abort(requestId), clearInterval(interval));
    }
    function errorCallback() {
      typeof failure == "function" && failure(), ImageLoader.abort(requestId), clearInterval(interval);
    }
  },
  has(uri) {
    return ImageUriCache.has(uri);
  },
  load(uri, onLoad, onError) {
    id += 1;
    const image = new window.Image();
    return image.onerror = onError, image.onload = (e) => {
      const onDecode = () => onLoad({ nativeEvent: e });
      typeof image.decode == "function" ? image.decode().then(onDecode, onDecode) : setTimeout(onDecode, 0);
    }, image.src = uri, requests[`${id}`] = image, id;
  },
  prefetch(uri) {
    return new Promise((resolve, reject) => {
      ImageLoader.load(
        uri,
        () => {
          ImageUriCache.add(uri), ImageUriCache.remove(uri), resolve();
        },
        reject
      );
    });
  },
  queryCache(uris) {
    const result = {};
    return uris.forEach((u) => {
      ImageUriCache.has(u) && (result[u] = "disk/memory");
    }), Promise.resolve(result);
  }
};
var ImageLoader_default = ImageLoader;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ImageUriCache
});
//# sourceMappingURL=index.js.map
