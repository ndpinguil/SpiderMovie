import getBoundingClientRect from "../getBoundingClientRect/index";
import setValueForStyles from "../setValueForStyles/index";
const getRect = (node) => {
  const { x, y, top, left } = getBoundingClientRect(node), width = node.offsetWidth, height = node.offsetHeight;
  return { x, y, width, height, top, left };
}, measureLayout = (node, relativeToNativeNode, callback) => {
  const relativeNode = relativeToNativeNode || node && node.parentNode;
  node && relativeNode && setTimeout(() => {
    const relativeRect = getBoundingClientRect(relativeNode), { height, left, top, width } = getRect(node), x = left - relativeRect.left, y = top - relativeRect.top;
    callback(x, y, width, height, left, top);
  }, 0);
}, focusableElements = {
  A: !0,
  INPUT: !0,
  SELECT: !0,
  TEXTAREA: !0
}, UIManager = {
  blur(node) {
    try {
      node.blur();
    } catch {
    }
  },
  focus(node) {
    try {
      const name = node.nodeName;
      node.getAttribute("tabIndex") == null && focusableElements[name] == null && node.setAttribute("tabIndex", "-1"), node.focus();
    } catch {
    }
  },
  measure(node, callback) {
    measureLayout(node, null, callback);
  },
  measureInWindow(node, callback) {
    node && setTimeout(() => {
      const { height, left, top, width } = getRect(node);
      callback(left, top, width, height);
    }, 0);
  },
  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    measureLayout(node, relativeToNativeNode, onSuccess);
  },
  updateView(node, props) {
    for (const prop in props) {
      if (!Object.prototype.hasOwnProperty.call(props, prop))
        continue;
      const value = props[prop];
      switch (prop) {
        case "style": {
          setValueForStyles(node, value);
          break;
        }
        case "class":
        case "className": {
          node.setAttribute("class", value);
          break;
        }
        case "text":
        case "value":
          node.value = value;
          break;
        default:
          node.setAttribute(prop, value);
      }
    }
  },
  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },
  // mocks
  setLayoutAnimationEnabledExperimental() {
  }
};
var UIManager_default = UIManager;
export {
  UIManager_default as default
};
//# sourceMappingURL=index.js.map
