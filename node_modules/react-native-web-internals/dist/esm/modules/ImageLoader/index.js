const dataUriPattern = /^data:/;
class ImageUriCache {
  static _maximumEntries = 256;
  static _entries = {};
  static has(uri) {
    const entries = ImageUriCache._entries;
    return dataUriPattern.test(uri) || !!entries[uri];
  }
  static add(uri) {
    const entries = ImageUriCache._entries, lastUsedTimestamp = Date.now();
    entries[uri] ? (entries[uri].lastUsedTimestamp = lastUsedTimestamp, entries[uri].refCount += 1) : entries[uri] = {
      lastUsedTimestamp,
      refCount: 1
    };
  }
  static remove(uri) {
    const entries = ImageUriCache._entries;
    entries[uri] && (entries[uri].refCount -= 1), ImageUriCache._cleanUpIfNeeded();
  }
  static _cleanUpIfNeeded() {
    const entries = ImageUriCache._entries, imageUris = Object.keys(entries);
    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {
      let leastRecentlyUsedKey, leastRecentlyUsedEntry;
      imageUris.forEach((uri) => {
        const entry = entries[uri];
        (!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0 && (leastRecentlyUsedKey = uri, leastRecentlyUsedEntry = entry);
      }), leastRecentlyUsedKey && delete entries[leastRecentlyUsedKey];
    }
  }
}
let id = 0;
const requests = {}, ImageLoader = {
  abort(requestId) {
    let image = requests[`${requestId}`];
    image && (image.onerror = null, image.onload = null, image = null, delete requests[`${requestId}`]);
  },
  getSize(uri, success, failure) {
    let complete = !1;
    const interval = setInterval(callback, 16), requestId = ImageLoader.load(uri, callback, errorCallback);
    function callback() {
      const image = requests[`${requestId}`];
      if (image) {
        const { naturalHeight, naturalWidth } = image;
        naturalHeight && naturalWidth && (success(naturalWidth, naturalHeight), complete = !0);
      }
      complete && (ImageLoader.abort(requestId), clearInterval(interval));
    }
    function errorCallback() {
      typeof failure == "function" && failure(), ImageLoader.abort(requestId), clearInterval(interval);
    }
  },
  has(uri) {
    return ImageUriCache.has(uri);
  },
  load(uri, onLoad, onError) {
    id += 1;
    const image = new window.Image();
    return image.onerror = onError, image.onload = (e) => {
      const onDecode = () => onLoad({ nativeEvent: e });
      typeof image.decode == "function" ? image.decode().then(onDecode, onDecode) : setTimeout(onDecode, 0);
    }, image.src = uri, requests[`${id}`] = image, id;
  },
  prefetch(uri) {
    return new Promise((resolve, reject) => {
      ImageLoader.load(
        uri,
        () => {
          ImageUriCache.add(uri), ImageUriCache.remove(uri), resolve();
        },
        reject
      );
    });
  },
  queryCache(uris) {
    const result = {};
    return uris.forEach((u) => {
      ImageUriCache.has(u) && (result[u] = "disk/memory");
    }), Promise.resolve(result);
  }
};
var ImageLoader_default = ImageLoader;
export {
  ImageUriCache,
  ImageLoader_default as default
};
//# sourceMappingURL=index.js.map
