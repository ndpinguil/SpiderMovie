var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var evaluateAstNode_exports = {};
__export(evaluateAstNode_exports, {
  evaluateAstNode: () => evaluateAstNode
});
module.exports = __toCommonJS(evaluateAstNode_exports);
var t = __toESM(require("@babel/types"));
function evaluateAstNode(exprNode, evalFn, shouldPrintDebug) {
  if (exprNode !== void 0) {
    if (exprNode === null)
      return !0;
    if (t.isJSXExpressionContainer(exprNode))
      return evaluateAstNode(exprNode.expression);
    if (t.isObjectExpression(exprNode)) {
      const ret = {};
      for (let idx = -1, len = exprNode.properties.length; ++idx < len; ) {
        const value = exprNode.properties[idx];
        if (!t.isObjectProperty(value))
          throw new Error("evaluateAstNode can only evaluate object properties");
        let key;
        if (value.computed) {
          if (typeof evalFn != "function")
            throw new Error(
              "evaluateAstNode does not support computed keys unless an eval function is provided"
            );
          key = evaluateAstNode(value.key, evalFn);
        } else if (t.isIdentifier(value.key))
          key = value.key.name;
        else if (t.isStringLiteral(value.key) || t.isNumericLiteral(value.key))
          key = value.key.value;
        else
          throw new Error("Unsupported key type: " + value.key.type);
        if (typeof key != "string" && typeof key != "number")
          throw new Error("key must be either a string or a number");
        ret[key] = evaluateAstNode(value.value, evalFn);
      }
      return ret;
    }
    if (t.isArrayExpression(exprNode))
      return exprNode.elements.map((x) => evaluateAstNode(x, evalFn));
    if (t.isUnaryExpression(exprNode) && exprNode.operator === "-") {
      const ret = evaluateAstNode(exprNode.argument, evalFn);
      return ret == null ? null : -ret;
    }
    if (t.isTemplateLiteral(exprNode)) {
      if (typeof evalFn != "function")
        throw new Error(
          "evaluateAstNode does not support template literals unless an eval function is provided"
        );
      let ret = "";
      for (let idx = -1, len = exprNode.quasis.length; ++idx < len; ) {
        const quasi = exprNode.quasis[idx], expr = exprNode.expressions[idx];
        ret += quasi.value.raw, expr && (ret += evaluateAstNode(expr, evalFn));
      }
      return ret;
    }
    if (t.isNullLiteral(exprNode))
      return null;
    if (t.isNumericLiteral(exprNode) || t.isStringLiteral(exprNode) || t.isBooleanLiteral(exprNode))
      return exprNode.value;
    if (t.isBinaryExpression(exprNode)) {
      if (exprNode.operator === "+")
        return evaluateAstNode(exprNode.left, evalFn) + evaluateAstNode(exprNode.right, evalFn);
      if (exprNode.operator === "-")
        return evaluateAstNode(exprNode.left, evalFn) - evaluateAstNode(exprNode.right, evalFn);
      if (exprNode.operator === "*")
        return evaluateAstNode(exprNode.left, evalFn) * evaluateAstNode(exprNode.right, evalFn);
      if (exprNode.operator === "/")
        return evaluateAstNode(exprNode.left, evalFn) / evaluateAstNode(exprNode.right, evalFn);
    }
    if (typeof evalFn != "function")
      throw new Error(
        "evaluateAstNode does not support non-literal values unless an eval function is provided"
      );
    return evalFn(exprNode);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  evaluateAstNode
});
//# sourceMappingURL=evaluateAstNode.js.map
