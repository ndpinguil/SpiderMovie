import { basename, relative } from "path";
import traverse from "@babel/traverse";
import * as t from "@babel/types";
import { Color, colorLog } from "@tamagui/cli-color";
import { createDOMProps } from "react-native-web-internals";
import { FAILED_EVAL } from "../constants";
import { requireTamaguiCore } from "../helpers/requireTamaguiCore";
import { createEvaluator, createSafeEvaluator } from "./createEvaluator";
import { evaluateAstNode } from "./evaluateAstNode";
import {
  attrStr,
  findComponentName,
  getValidComponent,
  getValidComponentsPaths,
  getValidImport,
  isPresent,
  isValidImport,
  objToStr
} from "./extractHelpers";
import { findTopmostFunction } from "./findTopmostFunction";
import { cleanupBeforeExit, getStaticBindingsForScope } from "./getStaticBindingsForScope";
import { literalToAst } from "./literalToAst";
import { loadTamagui, loadTamaguiSync } from "./loadTamagui";
import { logLines } from "./logLines";
import { normalizeTernaries } from "./normalizeTernaries";
import { setPropsToFontFamily } from "./propsToFontFamilyCache";
import { removeUnusedHooks } from "./removeUnusedHooks";
import { timer } from "./timer";
import { validHTMLAttributes } from "./validHTMLAttributes";
const UNTOUCHED_PROPS = {
  key: !0,
  style: !0,
  className: !0
}, INLINE_EXTRACTABLE = {
  ref: "ref",
  key: "key"
}, validHooks = {
  useMedia: !0,
  useTheme: !0
}, createTernary = (x) => x;
let hasLoggedBaseInfo = !1;
function isFullyDisabled(props) {
  return props.disableExtraction && props.disableDebugAttr;
}
function createExtractor({ logger = console } = { logger: console }) {
  const componentState = {
    focus: !1,
    hover: !1,
    unmounted: !0,
    press: !1,
    pressIn: !1
  }, styleProps = {
    resolveValues: "value",
    noClassNames: !1,
    isAnimated: !1
  }, shouldAddDebugProp = (
    // really basic disable this for next.js because it messes with ssr
    !process.env.npm_package_dependencies_next && !1
  );
  let projectInfo = null;
  function loadSync(props) {
    return isFullyDisabled(props) ? null : projectInfo ||= loadTamaguiSync(props);
  }
  async function load(props) {
    return isFullyDisabled(props) ? null : projectInfo ||= await loadTamagui(props);
  }
  return {
    options: {
      logger
    },
    cleanupBeforeExit,
    loadTamagui: load,
    loadTamaguiSync: loadSync,
    getTamagui() {
      return projectInfo?.tamaguiConfig;
    },
    parseSync: (f, props) => {
      const projectInfo2 = loadSync(props);
      return parseWithConfig(projectInfo2 || {}, f, props);
    },
    parse: async (f, props) => {
      const projectInfo2 = await load(props);
      return parseWithConfig(projectInfo2 || {}, f, props);
    }
  };
  function parseWithConfig({ components, tamaguiConfig }, fileOrPath, options) {
    const {
      config = "tamagui.config.ts",
      importsWhitelist = ["constants.js"],
      evaluateVars = !0,
      sourcePath = "",
      onExtractTag,
      onStyleRule,
      getFlattenedNode,
      disable,
      disableExtraction,
      disableExtractInlineMedia,
      disableExtractVariables,
      disableDebugAttr,
      enableDynamicEvaluation = !1,
      includeExtensions = [".ts", ".tsx", ".jsx"],
      extractStyledDefinitions = !1,
      prefixLogs,
      excludeProps,
      platform,
      ...restProps
    } = options;
    if (sourcePath.includes(".tamagui-dynamic-eval"))
      return null;
    const {
      expandStylesAndRemoveNullishValues,
      getSplitStyles,
      mediaQueryConfig,
      propMapper,
      proxyThemeVariables,
      pseudoDescriptors
    } = requireTamaguiCore(platform);
    let shouldPrintDebug = options.shouldPrintDebug || !1;
    if (disable === !0 || Array.isArray(disable) && disable.includes(sourcePath))
      return null;
    if (!isFullyDisabled(options) && !components)
      throw new Error("Must provide components");
    if (sourcePath && includeExtensions && !includeExtensions.some((ext) => sourcePath.endsWith(ext)))
      return shouldPrintDebug && logger.info(
        `Ignoring file due to includeExtensions: ${sourcePath}, includeExtensions: ${includeExtensions.join(
          ", "
        )}`
      ), null;
    function isValidStyleKey(name, staticConfig) {
      if (!projectInfo)
        throw new Error("Tamagui extractor not loaded yet");
      return platform === "native" && name[0] === "$" && mediaQueryConfig[name.slice(1)] ? !1 : !!(staticConfig.validStyles?.[name] || pseudoDescriptors[name] || // dont disable variants or else you lose many things flattening
      staticConfig.variants?.[name] || projectInfo?.tamaguiConfig?.shorthands[name] || name[0] === "$" && mediaQueryConfig[name.slice(1)]);
    }
    const isTargetingHTML = platform === "web", ogDebug = shouldPrintDebug, tm = timer(), propsWithFileInfo = {
      ...options,
      sourcePath,
      allLoadedComponents: components ? [...components] : []
    };
    hasLoggedBaseInfo || (hasLoggedBaseInfo = !0, shouldPrintDebug && logger.info(
      [
        "loaded components:",
        propsWithFileInfo.allLoadedComponents.map((comp) => Object.keys(comp.nameToInfo).join(", ")).join(", ")
      ].join(" ")
    ), process.env.DEBUG?.startsWith("tamagui") && logger.info(
      [
        "loaded:",
        JSON.stringify(propsWithFileInfo.allLoadedComponents, null, 2)
      ].join(`
`)
    )), tm.mark("load-tamagui", !!shouldPrintDebug), isFullyDisabled(options) || tamaguiConfig?.themes || (console.error(
      '\u26D4\uFE0F Error: Missing "themes" in your tamagui.config file, this may be due to duplicated dependency versions. Try out https://github.com/bmish/check-dependency-version-consistency to see if there are mis-matches, or search your lockfile.'
    ), console.log("  Got config:", tamaguiConfig), process.exit(0));
    const firstThemeName = Object.keys(tamaguiConfig?.themes || {})[0], firstTheme = tamaguiConfig?.themes[firstThemeName] || {};
    (!firstTheme || typeof firstTheme != "object") && (console.error("Missing theme, an error occurred when importing your config"), console.log("Got config:", tamaguiConfig), console.log("Looking for theme:", firstThemeName), process.exit(0));
    const proxiedTheme = proxyThemeVariables(firstTheme), themeAccessListeners = /* @__PURE__ */ new Set(), defaultTheme = new Proxy(proxiedTheme, {
      get(target, key) {
        return Reflect.has(target, key) && themeAccessListeners.forEach((cb) => cb(String(key))), Reflect.get(target, key);
      }
    }), body = fileOrPath.type === "Program" ? fileOrPath.get("body") : fileOrPath.program.body;
    isFullyDisabled(options) || Object.keys(components || []).length === 0 && (console.warn(
      "Warning: Tamagui didn't find any valid components (DEBUG=tamagui for more)"
    ), process.env.DEBUG === "tamagui" && console.log("components", Object.keys(components || []), components)), shouldPrintDebug === "verbose" && logger.info(
      `allLoadedComponent modules ${propsWithFileInfo.allLoadedComponents.map((k) => k.moduleName).join(", ")}`
    );
    let doesUseValidImport = !1, hasImportedTheme = !1;
    const importDeclarations = [];
    for (const bodyPath of body) {
      if (bodyPath.type !== "ImportDeclaration")
        continue;
      const node = "node" in bodyPath ? bodyPath.node : bodyPath, moduleName = node.source.value, valid = isValidImport(propsWithFileInfo, moduleName);
      if (valid && importDeclarations.push(node), extractStyledDefinitions && valid && node.specifiers.some((specifier) => specifier.local.name === "styled")) {
        doesUseValidImport = !0;
        break;
      }
      if (valid) {
        const names = node.specifiers.map((specifier) => specifier.local.name), isValidComponent = names.some(
          (name) => !!(isValidImport(propsWithFileInfo, moduleName, name) || validHooks[name])
        );
        if (shouldPrintDebug === "verbose" && logger.info(
          ` - import ${isValidComponent ? "\u2705" : "\u21E3"} - ${names.join(
            ", "
          )} from '${moduleName}' - (valid: ${JSON.stringify(
            getValidComponentsPaths(propsWithFileInfo)
          )})`
        ), isValidComponent) {
          doesUseValidImport = !0;
          break;
        }
      }
    }
    if (shouldPrintDebug && logger.info(
      `${JSON.stringify({ doesUseValidImport, hasImportedTheme }, null, 2)}
`
    ), !doesUseValidImport)
      return null;
    function getValidImportedComponent(componentName) {
      const importDeclaration = importDeclarations.find(
        (dec) => dec.specifiers.some((spec) => spec.local.name === componentName)
      );
      return importDeclaration ? getValidImport(
        propsWithFileInfo,
        importDeclaration.source.value,
        componentName
      ) : null;
    }
    tm.mark("import-check", !!shouldPrintDebug);
    let couldntParse = !1;
    const modifiedComponents = /* @__PURE__ */ new Set(), bindingCache = {}, callTraverse = (a) => fileOrPath.type === "File" ? traverse(fileOrPath, a) : fileOrPath.traverse(a), shouldDisableExtraction = disableExtraction === !0 || Array.isArray(disableExtraction) && disableExtraction.includes(sourcePath);
    let programPath = null;
    const res = {
      styled: 0,
      flattened: 0,
      optimized: 0,
      modified: 0,
      found: 0
    }, version = `${Math.random()}`;
    if (callTraverse({
      // @ts-ignore
      Program: {
        enter(path) {
          programPath = path;
        }
      },
      // styled() calls
      CallExpression(path) {
        if (disable || shouldDisableExtraction || extractStyledDefinitions === !1 || !t.isIdentifier(path.node.callee) || path.node.callee.name !== "styled")
          return;
        const variableName = t.isVariableDeclarator(path.parent) && t.isIdentifier(path.parent.id) ? path.parent.id.name : "unknown", parentNode = path.node.arguments[0];
        if (!t.isIdentifier(parentNode))
          return;
        const parentName = parentNode.name, definition = path.node.arguments[1];
        if (!parentName || !definition || !t.isObjectExpression(definition))
          return;
        let Component = getValidImportedComponent(variableName);
        if (!Component) {
          if (enableDynamicEvaluation !== !0)
            return;
          try {
            shouldPrintDebug && logger.info(
              `Unknown component: ${variableName} = styled(${parentName}) attempting dynamic load: ${sourcePath}`
            );
            const out2 = loadTamaguiSync({
              forceExports: !0,
              components: [sourcePath],
              cacheKey: version
            });
            if (!out2?.components) {
              shouldPrintDebug && logger.info(`Couldn't load, got ${out2}`);
              return;
            }
            if (propsWithFileInfo.allLoadedComponents = [
              ...propsWithFileInfo.allLoadedComponents,
              ...out2.components
            ], Component = out2.components.flatMap((x) => x.nameToInfo[variableName] ?? [])[0], !out2.cached) {
              const foundNames = out2.components?.map((x) => Object.keys(x.nameToInfo).join(", ")).join(", ").trim();
              foundNames && colorLog(
                Color.FgYellow,
                `      | Tamagui found dynamic components: ${foundNames}`
              );
            }
          } catch {
            shouldPrintDebug && logger.info(
              `skip optimize styled(${variableName}), unable to pre-process (DEBUG=tamagui for more)`
            );
          }
        }
        if (!Component) {
          shouldPrintDebug && logger.info(" No component found");
          return;
        }
        const componentSkipProps = /* @__PURE__ */ new Set([
          ...Component.staticConfig.inlineWhenUnflattened || [],
          ...Component.staticConfig.inlineProps || [],
          ...Component.staticConfig.deoptProps || [],
          // for now skip variants, will return to them
          "variants",
          "defaultVariants",
          // skip fontFamily its basically a "variant", important for theme use to be value always
          "fontFamily",
          "name",
          "focusStyle",
          "hoverStyle",
          "pressStyle"
        ]), skipped = /* @__PURE__ */ new Set(), styles = {}, staticNamespace = getStaticBindingsForScope(
          path.scope,
          importsWhitelist,
          sourcePath,
          bindingCache,
          shouldPrintDebug
        ), attemptEval = evaluateVars ? createEvaluator({
          props: propsWithFileInfo,
          staticNamespace,
          sourcePath,
          shouldPrintDebug
        }) : evaluateAstNode, attemptEvalSafe = createSafeEvaluator(attemptEval);
        for (const property of definition.properties) {
          if (!t.isObjectProperty(property) || !t.isIdentifier(property.key) || !isValidStyleKey(property.key.name, Component.staticConfig) || // TODO make pseudos and variants work
          // skip pseudos
          pseudoDescriptors[property.key.name] || // skip variants
          Component.staticConfig.variants?.[property.key.name] || componentSkipProps.has(property.key.name)) {
            skipped.add(property);
            continue;
          }
          const out2 = attemptEvalSafe(property.value);
          out2 === FAILED_EVAL ? skipped.add(property) : styles[property.key.name] = out2;
        }
        const out = getSplitStyles(
          styles,
          Component.staticConfig,
          defaultTheme,
          "",
          componentState,
          styleProps,
          void 0,
          void 0,
          void 0,
          shouldPrintDebug
        ), classNames = {
          ...out.classNames
        };
        if (shouldPrintDebug && logger.info(
          [
            `Extracted styled(${variableName})
`,
            JSON.stringify(styles, null, 2),
            `
 classNames:`,
            JSON.stringify(classNames, null, 2),
            `
  rulesToInsert:`,
            out.rulesToInsert.flatMap((rule) => rule.rules).join(`
`)
          ].join(" ")
        ), definition.properties = definition.properties.map((prop) => {
          if (skipped.has(prop) || !t.isObjectProperty(prop) || !t.isIdentifier(prop.key))
            return prop;
          const key = prop.key.name, value = classNames[key];
          return value ? t.objectProperty(t.stringLiteral(key), t.stringLiteral(value)) : prop;
        }), out.rulesToInsert)
          for (const { identifier, rules } of out.rulesToInsert)
            onStyleRule?.(identifier, rules);
        res.styled++, shouldPrintDebug && logger.info(`Extracted styled(${variableName})`);
      },
      JSXElement(traversePath) {
        tm.mark("jsx-element", !!shouldPrintDebug);
        const node = traversePath.node.openingElement, ogAttributes = node.attributes.map((attr) => ({ ...attr })), componentName = findComponentName(traversePath.scope), closingElement = traversePath.node.closingElement;
        if (t.isJSXMemberExpression(closingElement?.name) || !t.isJSXIdentifier(node.name))
          return;
        const binding = traversePath.scope.getBinding(node.name.name);
        let moduleName = "";
        if (binding && t.isImportDeclaration(binding.path.parent) && (moduleName = binding.path.parent.source.value, !isValidImport(propsWithFileInfo, moduleName, binding.identifier.name))) {
          shouldPrintDebug && logger.info(
            ` - Binding for ${componentName} not internal import or from components ${binding.identifier.name} in ${moduleName}`
          );
          return;
        }
        const component = getValidComponent(propsWithFileInfo, moduleName, node.name.name);
        if (!component || !component.staticConfig) {
          shouldPrintDebug && logger.info(` - No Tamagui conf on this: ${node.name.name}`);
          return;
        }
        const originalNodeName = node.name.name;
        res.found++;
        const filePath = `./${relative(process.cwd(), sourcePath)}`, lineNumbers = node.loc ? node.loc.start.line + (node.loc.start.line !== node.loc.end.line ? `-${node.loc.end.line}` : "") : "", codePosition = `${filePath}:${lineNumbers}`, debugPropValue = node.attributes.filter(
          (n) => t.isJSXAttribute(n) && t.isJSXIdentifier(n.name) && n.name.name === "debug"
        ).map((n) => n.value === null ? !0 : t.isStringLiteral(n.value) ? n.value.value : !1)[0];
        if (debugPropValue && (shouldPrintDebug = debugPropValue), shouldPrintDebug && (logger.info(`
`), logger.info(
          `\x1B[33m%s\x1B[0m ${componentName} | ${codePosition} -------------------`
        ), logger.info(["\x1B[1m", "\x1B[32m", `<${originalNodeName} />`, disableDebugAttr ? "" : "\u{1F41B}"].join(" "))), shouldAddDebugProp && !disableDebugAttr && (res.modified++, node.attributes.unshift(
          t.jsxAttribute(t.jsxIdentifier("data-is"), t.stringLiteral(node.name.name))
        ), componentName && node.attributes.unshift(
          t.jsxAttribute(t.jsxIdentifier("data-in"), t.stringLiteral(componentName))
        ), node.attributes.unshift(
          t.jsxAttribute(
            t.jsxIdentifier("data-at"),
            t.stringLiteral(`${basename(filePath)}:${lineNumbers}`)
          )
        )), shouldDisableExtraction) {
          shouldPrintDebug === "verbose" && console.log(" Extraction disabled");
          return;
        }
        try {
          let evaluateAttribute2 = function(path) {
            const attribute = path.node, attr = { type: "attr", value: attribute };
            if (t.isJSXSpreadAttribute(attribute)) {
              const arg = attribute.argument, conditional = t.isConditionalExpression(arg) ? (
                // <YStack {...isSmall ? { color: 'red } : { color: 'blue }}
                [arg.test, arg.consequent, arg.alternate]
              ) : t.isLogicalExpression(arg) && arg.operator === "&&" ? (
                // <YStack {...isSmall && { color: 'red }}
                [arg.left, arg.right, null]
              ) : null;
              if (conditional) {
                const [test, alt, cons] = conditional;
                if (!test)
                  throw new Error("no test");
                return [alt, cons].some((side) => side && !isStaticObject2(side)) ? (shouldPrintDebug && logger.info(`not extractable ${alt} ${cons}`), attr) : [
                  ...createTernariesFromObjectProperties2(test, alt) || [],
                  ...cons && createTernariesFromObjectProperties2(
                    t.unaryExpression("!", test),
                    cons
                  ) || []
                ].map((ternary) => ({
                  type: "ternary",
                  value: ternary
                }));
              }
            }
            if (t.isJSXSpreadAttribute(attribute) || !attribute.name || typeof attribute.name.name != "string")
              return shouldPrintDebug && logger.info("  ! inlining, spread attr"), inlined.set(`${Math.random()}`, "spread"), attr;
            const name = attribute.name.name;
            if (excludeProps?.has(name))
              return shouldPrintDebug && logger.info(["  excluding prop", name].join(" ")), null;
            if (inlineProps.has(name))
              return inlined.set(name, name), shouldPrintDebug && logger.info(["  ! inlining, inline prop", name].join(" ")), attr;
            if (deoptProps.has(name))
              return shouldDeopt = !0, inlined.set(name, name), shouldPrintDebug && logger.info(["  ! inlining, deopted prop", name].join(" ")), attr;
            if (UNTOUCHED_PROPS[name])
              return attr;
            if (INLINE_EXTRACTABLE[name])
              return inlined.set(name, INLINE_EXTRACTABLE[name]), attr;
            if (name.startsWith("data-"))
              return attr;
            if (name[0] === "$" && t.isJSXExpressionContainer(attribute?.value)) {
              const shortname = name.slice(1);
              if (mediaQueryConfig[shortname]) {
                if (platform === "native" && (shouldDeopt = !0), disableExtractInlineMedia)
                  return attr;
                const expression = attribute.value.expression;
                if (!t.isJSXEmptyExpression(expression)) {
                  const ternaries2 = createTernariesFromObjectProperties2(
                    t.stringLiteral(shortname),
                    expression,
                    {
                      inlineMediaQuery: shortname
                    }
                  );
                  if (ternaries2)
                    return ternaries2.map((value2) => ({
                      type: "ternary",
                      value: value2
                    }));
                }
              }
            }
            const [value, valuePath] = (() => t.isJSXExpressionContainer(attribute?.value) ? [attribute.value.expression, path.get("value")] : [attribute.value, path.get("value")])(), remove = () => {
              Array.isArray(valuePath) ? valuePath.map((p) => p.remove()) : valuePath.remove();
            };
            if (name === "ref")
              return shouldPrintDebug && logger.info(["  ! inlining, ref", name].join(" ")), inlined.set("ref", "ref"), attr;
            if (name === "tag")
              return {
                type: "attr",
                value: path.node
              };
            if (disableExtractVariables === !0 && value && value.type === "StringLiteral" && value.value[0] === "$")
              return shouldPrintDebug && logger.info(
                [
                  `  ! inlining, native disable extract: ${name} =`,
                  value.value
                ].join(" ")
              ), inlined.set(name, !0), attr;
            if (name === "theme")
              return inlined.set("theme", attr.value), attr;
            const styleValue = attemptEvalSafe(value);
            if (!variants[name] && !isValidStyleKey(name, staticConfig)) {
              let keys = [name], out = null;
              out = propMapper(name, styleValue, propMapperStyleState), out && (Array.isArray(out) ? (out = Object.fromEntries(out), keys = Object.keys(out)) : (logger.warn("Error expected array but got", out), couldntParse = !0, shouldDeopt = !0)), out && (isTargetingHTML && (out = createDOMProps(isTextView ? "span" : "div", out), delete out.className), keys = Object.keys(out));
              let didInline = !1;
              const attributes = keys.map((key) => {
                const val = out[key];
                return isValidStyleKey(key, staticConfig) ? {
                  type: "style",
                  value: { [key]: styleValue },
                  name: key,
                  attr: path.node
                } : validHTMLAttributes[key] || key.startsWith("aria-") || key.startsWith("data-") || // this is debug stuff added by vite / new jsx transform
                key === "__source" || key === "__self" ? attr : (shouldPrintDebug && logger.info("  ! inlining, non-static " + key), didInline = !0, inlined.set(key, val), val);
              });
              return didInline ? (shouldPrintDebug && logger.info(`  bailing flattening due to attributes ${attributes}`), attr) : attributes;
            }
            if (styleValue !== FAILED_EVAL)
              return inlineWhenUnflattened.has(name) && (inlineWhenUnflattenedOGVals[name] = { styleValue, attr }), isValidStyleKey(name, staticConfig) ? (shouldPrintDebug && logger.info(`  style: ${name} = ${styleValue}`), name in defaultProps || hasSetOptimized || (res.optimized++, hasSetOptimized = !0), {
                type: "style",
                value: { [name]: styleValue },
                name,
                attr: path.node
              }) : (variants[name] && variantValues.set(name, styleValue), inlined.set(name, !0), attr);
            if (t.isBinaryExpression(value)) {
              shouldPrintDebug && logger.info(` binary expression ${name} = ${value}`);
              const { operator, left, right } = value, lVal = attemptEvalSafe(left), rVal = attemptEvalSafe(right);
              if (shouldPrintDebug && logger.info(
                `  evalBinaryExpression lVal ${String(lVal)}, rVal ${String(rVal)}`
              ), lVal !== FAILED_EVAL && t.isConditionalExpression(right)) {
                const ternary = addBinaryConditional(operator, left, right);
                if (ternary)
                  return ternary;
              }
              if (rVal !== FAILED_EVAL && t.isConditionalExpression(left)) {
                const ternary = addBinaryConditional(operator, right, left);
                if (ternary)
                  return ternary;
              }
              return shouldPrintDebug && logger.info("  evalBinaryExpression cant extract"), inlined.set(name, !0), attr;
            }
            const staticConditional = getStaticConditional(value);
            if (staticConditional)
              return shouldPrintDebug === "verbose" && logger.info(` static conditional ${name} ${value}`), { type: "ternary", value: staticConditional };
            const staticLogical = getStaticLogical(value);
            if (staticLogical)
              return shouldPrintDebug === "verbose" && logger.info(` static ternary ${name} =  ${value}`), { type: "ternary", value: staticLogical };
            return inlined.set(name, !0), shouldPrintDebug && logger.info(` ! inline no match ${name} ${value}`), attr;
            function addBinaryConditional(operator, staticExpr, cond) {
              if (getStaticConditional(cond)) {
                const alt = attemptEval(
                  t.binaryExpression(operator, staticExpr, cond.alternate)
                ), cons = attemptEval(
                  t.binaryExpression(operator, staticExpr, cond.consequent)
                );
                return shouldPrintDebug && logger.info(["  binaryConditional", cond.test, cons, alt].join(" ")), {
                  type: "ternary",
                  value: {
                    test: cond.test,
                    remove,
                    alternate: { [name]: alt },
                    consequent: { [name]: cons }
                  }
                };
              }
              return null;
            }
            function getStaticConditional(value2) {
              if (t.isConditionalExpression(value2))
                try {
                  const aVal = attemptEval(value2.alternate), cVal = attemptEval(value2.consequent);
                  if (shouldPrintDebug) {
                    const type = value2.test.type;
                    logger.info(["      static ternary", type, cVal, aVal].join(" "));
                  }
                  return {
                    test: value2.test,
                    remove,
                    consequent: { [name]: cVal },
                    alternate: { [name]: aVal }
                  };
                } catch (err) {
                  shouldPrintDebug && logger.info(["       cant eval ternary", err.message].join(" "));
                }
              return null;
            }
            function getStaticLogical(value2) {
              if (t.isLogicalExpression(value2) && value2.operator === "&&")
                try {
                  const val = attemptEval(value2.right);
                  return shouldPrintDebug && logger.info(["  staticLogical", value2.left, name, val].join(" ")), {
                    test: value2.left,
                    remove,
                    consequent: { [name]: val },
                    alternate: null
                  };
                } catch (err) {
                  shouldPrintDebug && logger.info(["  cant static eval logical", err].join(" "));
                }
              return null;
            }
          }, isStaticObject2 = function(obj) {
            return t.isObjectExpression(obj) && obj.properties.every((prop) => {
              if (!t.isObjectProperty(prop))
                return logger.info(["not object prop", prop].join(" ")), !1;
              const propName = prop.key.name;
              return !isValidStyleKey(propName, staticConfig) && propName !== "tag" ? (shouldPrintDebug && logger.info(["  not a valid style prop!", propName].join(" ")), !1) : !0;
            });
          }, createTernariesFromObjectProperties2 = function(test, side, ternaryPartial = {}) {
            if (!side)
              return null;
            if (!isStaticObject2(side))
              throw new Error("not extractable");
            return side.properties.flatMap((property) => {
              if (!t.isObjectProperty(property))
                throw new Error("expected object property");
              if (t.isIdentifier(property.key)) {
                const key = property.key.name, mediaQueryKey = key.slice(1);
                if (key[0] === "$" && mediaQueryConfig[mediaQueryKey])
                  if (t.isExpression(property.value)) {
                    const ternaries2 = createTernariesFromObjectProperties2(
                      t.stringLiteral(mediaQueryKey),
                      property.value,
                      {
                        inlineMediaQuery: mediaQueryKey
                      }
                    );
                    if (ternaries2)
                      return ternaries2.map((value) => ({
                        ...ternaryPartial,
                        ...value,
                        // ensure media query test stays on left side (see getMediaQueryTernary)
                        test: t.logicalExpression("&&", value.test, test)
                      }));
                    logger.info(["\u26A0\uFE0F no ternaries?", property].join(" "));
                  } else
                    logger.info(["\u26A0\uFE0F not expression", property].join(" "));
              }
              if (t.isConditionalExpression(property.value)) {
                const [truthy, falsy] = [
                  t.objectExpression([
                    t.objectProperty(property.key, property.value.consequent)
                  ]),
                  t.objectExpression([
                    t.objectProperty(property.key, property.value.alternate)
                  ])
                ].map((x) => attemptEval(x));
                return [
                  createTernary({
                    remove() {
                    },
                    ...ternaryPartial,
                    test: t.logicalExpression("&&", test, property.value.test),
                    consequent: truthy,
                    alternate: null
                  }),
                  createTernary({
                    ...ternaryPartial,
                    test: t.logicalExpression(
                      "&&",
                      test,
                      t.unaryExpression("!", property.value.test)
                    ),
                    consequent: falsy,
                    alternate: null,
                    remove() {
                    }
                  })
                ];
              }
              const obj = t.objectExpression([
                t.objectProperty(property.key, property.value)
              ]), consequent = attemptEval(obj);
              return createTernary({
                remove() {
                },
                ...ternaryPartial,
                test,
                consequent,
                alternate: null
              });
            });
          }, mergeToEnd2 = function(obj, key, val) {
            key in obj && delete obj[key], obj[key] = val;
          }, expandStylesAndRemoveNullishValuesWithoutVariants2 = function(style) {
            let res2 = {};
            for (const key in style)
              if (staticConfig.variants && key in staticConfig.variants)
                mergeToEnd2(res2, key, style[key]);
              else {
                const expanded = expandStylesAndRemoveNullishValues({ [key]: style[key] });
                for (const key2 in expanded)
                  mergeToEnd2(res2, key2, expanded[key2]);
              }
            return res2;
          }, mergeStyles2 = function(prev2, next) {
            for (const key in next)
              pseudoDescriptors[key] ? (prev2[key] = prev2[key] || {}, Object.assign(prev2[key], next[key])) : mergeToEnd2(prev2, key, next[key]);
          };
          var evaluateAttribute = evaluateAttribute2, isStaticObject = isStaticObject2, createTernariesFromObjectProperties = createTernariesFromObjectProperties2, mergeToEnd = mergeToEnd2, expandStylesAndRemoveNullishValuesWithoutVariants = expandStylesAndRemoveNullishValuesWithoutVariants2, mergeStyles = mergeStyles2;
          const { staticConfig } = component, defaultProps = { ...staticConfig.defaultProps || {} }, variants = staticConfig.variants || {}, isTextView = staticConfig.isText || !1, validStyles = staticConfig?.validStyles ?? {};
          let tagName = defaultProps.tag ?? (isTextView ? "span" : "div");
          traversePath.get("openingElement").get("attributes").forEach((path) => {
            const attr = path.node;
            if (t.isJSXSpreadAttribute(attr) || attr.name.name !== "tag")
              return;
            const val = attr.value;
            t.isStringLiteral(val) && (tagName = val.value);
          }), shouldPrintDebug === "verbose" && console.log(` Start tag ${tagName}`);
          const flatNode = getFlattenedNode?.({ isTextView, tag: tagName }), inlineProps = /* @__PURE__ */ new Set([
            // adding some always inline props
            "dataSet",
            ...restProps.inlineProps || [],
            ...staticConfig.inlineProps || []
          ]), deoptProps = /* @__PURE__ */ new Set([
            // always de-opt animation these
            "animation",
            "disableOptimization",
            // when using a non-CSS driver, de-opt on enterStyle/exitStyle
            ...tamaguiConfig?.animations.isReactNative ? ["enterStyle", "exitStyle"] : [],
            ...restProps.deoptProps || [],
            ...staticConfig.deoptProps || []
          ]), inlineWhenUnflattened = /* @__PURE__ */ new Set([
            ...staticConfig.inlineWhenUnflattened || []
          ]), staticNamespace = getStaticBindingsForScope(
            traversePath.scope,
            importsWhitelist,
            sourcePath,
            bindingCache,
            shouldPrintDebug
          ), attemptEval = evaluateVars ? createEvaluator({
            props: propsWithFileInfo,
            staticNamespace,
            sourcePath,
            traversePath,
            shouldPrintDebug
          }) : evaluateAstNode, attemptEvalSafe = createSafeEvaluator(attemptEval);
          if (shouldPrintDebug && logger.info(`  staticNamespace ${Object.keys(staticNamespace).join(", ")}`), couldntParse)
            return;
          tm.mark("jsx-element-flattened", !!shouldPrintDebug);
          let attrs = [], shouldDeopt = !1;
          const inlined = /* @__PURE__ */ new Map(), variantValues = /* @__PURE__ */ new Map();
          let hasSetOptimized = !1;
          const inlineWhenUnflattenedOGVals = {}, propMapperStyleState = {
            staticConfig,
            usedKeys: {},
            classNames: {},
            style: {},
            theme: defaultTheme,
            viewProps: defaultProps,
            conf: tamaguiConfig,
            curProps: defaultProps,
            props: defaultProps,
            componentState,
            styleProps: {
              ...styleProps,
              resolveValues: "auto"
            },
            debug: shouldPrintDebug
          };
          if (attrs = traversePath.get("openingElement").get("attributes").flatMap((path) => {
            try {
              const res2 = evaluateAttribute2(path);
              return tm.mark("jsx-element-evaluate-attr", !!shouldPrintDebug), res2 || path.remove(), res2;
            } catch (err) {
              return shouldPrintDebug && (logger.info(
                [
                  "Recoverable error extracting attribute",
                  err.message,
                  shouldPrintDebug === "verbose" ? err.stack : ""
                ].join(" ")
              ), shouldPrintDebug === "verbose" && logger.info(`node ${path.node?.type}`)), inlined.set(`${Math.random()}`, "spread"), {
                type: "attr",
                value: path.node
              };
            }
          }).flat(4).filter(isPresent), shouldPrintDebug && logger.info(
            [`  - attrs (before):
`, logLines(attrs.map(attrStr).join(", "))].join(" ")
          ), couldntParse || shouldDeopt) {
            shouldPrintDebug && logger.info(
              ["  avoid optimizing:", { couldntParse, shouldDeopt }].join(" ")
            ), node.attributes = ogAttributes;
            return;
          }
          const parentFn = findTopmostFunction(traversePath);
          parentFn && modifiedComponents.add(parentFn);
          let ternaries = [];
          attrs = attrs.reduce((out, cur) => {
            const next = attrs[attrs.indexOf(cur) + 1];
            if (cur.type === "ternary" && ternaries.push(cur.value), (!next || next.type !== "ternary") && ternaries.length) {
              const normalized = normalizeTernaries(ternaries).map(
                ({ alternate, consequent, ...rest }) => ({
                  type: "ternary",
                  value: {
                    ...rest,
                    alternate: alternate || null,
                    consequent: consequent || null
                  }
                })
              );
              try {
                return [...out, ...normalized];
              } finally {
                shouldPrintDebug && logger.info(
                  `    normalizeTernaries (${ternaries.length} => ${normalized.length})`
                ), ternaries = [];
              }
            }
            return cur.type === "ternary" || out.push(cur), out;
          }, []).flat();
          const hasSpread = attrs.some(
            (x) => x.type === "attr" && t.isJSXSpreadAttribute(x.value)
          ), hasOnlyStringChildren = !hasSpread && (node.selfClosing || traversePath.node.children && traversePath.node.children.every((x) => x.type === "JSXText")), themeVal = inlined.get("theme");
          platform !== "native" && inlined.delete("theme");
          for (const [key] of [...inlined]) {
            const isStaticObjectVariant = staticConfig.variants?.[key] && variantValues.has(key);
            (INLINE_EXTRACTABLE[key] || isStaticObjectVariant) && inlined.delete(key);
          }
          const canFlattenProps = inlined.size === 0;
          let shouldFlatten = !!(flatNode && !shouldDeopt && canFlattenProps && !hasSpread && !staticConfig.isStyledHOC && !staticConfig.isHOC && !staticConfig.isReactNative && staticConfig.neverFlatten !== !0 && (staticConfig.neverFlatten !== "jsx" || hasOnlyStringChildren));
          const shouldWrapTheme = shouldFlatten && themeVal, usedThemeKeys = /* @__PURE__ */ new Set();
          if (disableExtractVariables && themeAccessListeners.add((key) => {
            shouldFlatten = !1, usedThemeKeys.add(key), shouldPrintDebug === "verbose" && logger.info([" ! accessing theme key, avoid flatten", key].join(" "));
          }), shouldPrintDebug)
            try {
              logger.info([" flatten?", shouldFlatten, objToStr({ hasSpread, shouldDeopt, canFlattenProps, shouldWrapTheme, hasOnlyStringChildren }), "inlined", inlined.size, [...inlined]].join(" "));
            } catch {
            }
          if (shouldFlatten && shouldWrapTheme && (programPath ? (shouldPrintDebug && logger.info(["  - wrapping theme", themeVal].join(" ")), attrs = attrs.filter(
            (x) => !(x.type === "attr" && t.isJSXAttribute(x.value) && x.value.name.name === "theme")
          ), hasImportedTheme || (hasImportedTheme = !0, programPath.node.body.push(
            t.importDeclaration(
              [
                t.importSpecifier(
                  t.identifier("_TamaguiTheme"),
                  t.identifier("Theme")
                )
              ],
              t.stringLiteral("@tamagui/web")
            )
          )), traversePath.replaceWith(
            t.jsxElement(
              t.jsxOpeningElement(t.jsxIdentifier("_TamaguiTheme"), [
                t.jsxAttribute(t.jsxIdentifier("name"), themeVal.value)
              ]),
              t.jsxClosingElement(t.jsxIdentifier("_TamaguiTheme")),
              [traversePath.node]
            )
          )) : console.warn(
            `No program path found, avoiding importing flattening / importing theme in ${sourcePath}`
          )), shouldFlatten) {
            const defaultStyleAttrs = Object.keys(defaultProps).flatMap((key) => {
              if (!isValidStyleKey(key, staticConfig))
                return [];
              const value = defaultProps[key], name = tamaguiConfig?.shorthands[key] || key;
              if (value === void 0) {
                logger.warn(
                  `\u26A0\uFE0F Error evaluating default style for component, prop ${key} ${value}`
                ), shouldDeopt = !0;
                return;
              }
              return {
                type: "style",
                name,
                value: { [name]: value }
              };
            });
            defaultStyleAttrs.length && (attrs = [...defaultStyleAttrs, ...attrs]);
          }
          if (shouldDeopt || !shouldFlatten) {
            shouldPrintDebug && logger.info(`Deopting ${shouldDeopt} ${shouldFlatten}`), node.attributes = ogAttributes;
            return;
          }
          shouldPrintDebug && logger.info(
            [`  - attrs (flattened): 
`, logLines(attrs.map(attrStr).join(", "))].join(
              " "
            )
          );
          let foundStaticProps = {};
          for (const key in attrs) {
            const cur = attrs[key];
            if (cur.type === "style") {
              const expanded = expandStylesAndRemoveNullishValuesWithoutVariants2(
                cur.value
              );
              for (const key2 in expanded)
                mergeToEnd2(foundStaticProps, key2, expanded[key2]);
              continue;
            }
            if (cur.type === "attr") {
              if (t.isJSXSpreadAttribute(cur.value) || !t.isJSXIdentifier(cur.value.name))
                continue;
              const key2 = cur.value.name.name, value = attemptEvalSafe(cur.value.value || t.booleanLiteral(!0));
              value !== FAILED_EVAL && mergeToEnd2(foundStaticProps, key2, value);
            }
          }
          const completeProps = {};
          for (const key in defaultProps)
            key in foundStaticProps || (completeProps[key] = defaultProps[key]);
          for (const key in foundStaticProps)
            completeProps[key] = foundStaticProps[key];
          attrs = attrs.reduce((acc, cur) => {
            if (!cur)
              return acc;
            if (cur.type === "attr" && !t.isJSXSpreadAttribute(cur.value) && shouldFlatten) {
              const name = cur.value.name.name;
              if (typeof name == "string") {
                if (name === "tag")
                  return acc;
                if (variants[name] && variantValues.has(name)) {
                  const styleState = {
                    ...propMapperStyleState,
                    props: completeProps,
                    curProps: completeProps
                  };
                  let out = Object.fromEntries(
                    propMapper(name, variantValues.get(name), styleState) || []
                  );
                  if (out && isTargetingHTML) {
                    const cn = out.className;
                    out = createDOMProps(isTextView ? "span" : "div", out), out.className = cn;
                  }
                  shouldPrintDebug && logger.info([" - expanded variant", name, out].join(" "));
                  for (const key2 in out) {
                    const value2 = out[key2];
                    isValidStyleKey(key2, staticConfig) ? acc.push({
                      type: "style",
                      value: { [key2]: value2 },
                      name: key2,
                      attr: cur.value
                    }) : acc.push({
                      type: "attr",
                      value: t.jsxAttribute(
                        t.jsxIdentifier(key2),
                        t.jsxExpressionContainer(
                          typeof value2 == "string" ? t.stringLiteral(value2) : literalToAst(value2)
                        )
                      )
                    });
                  }
                }
              }
            }
            if (cur.type !== "style")
              return acc.push(cur), acc;
            let key = Object.keys(cur.value)[0];
            const value = cur.value[key], fullKey = tamaguiConfig?.shorthands[key];
            return fullKey && (cur.value = { [fullKey]: value }, key = fullKey), disableExtractVariables && value[0] === "$" && (usedThemeKeys.has(key) || usedThemeKeys.has(fullKey)) ? (shouldPrintDebug && logger.info([`   keeping variable inline: ${key} =`, value].join(" ")), acc.push({
              type: "attr",
              value: t.jsxAttribute(
                t.jsxIdentifier(key),
                t.jsxExpressionContainer(t.stringLiteral(value))
              )
            }), acc) : (acc.push(cur), acc);
          }, []), tm.mark("jsx-element-expanded", !!shouldPrintDebug), shouldPrintDebug && logger.info(
            [`  - attrs (expanded): 
`, logLines(attrs.map(attrStr).join(", "))].join(
              " "
            )
          );
          let prev = null;
          const getProps = (props, includeProps = !1, debugName = "") => {
            if (!props)
              return shouldPrintDebug && logger.info([" getProps() no props"].join(" ")), {};
            if (excludeProps?.size)
              for (const key in props)
                excludeProps.has(key) && (shouldPrintDebug && logger.info([" delete excluded", key].join(" ")), delete props[key]);
            try {
              const out = getSplitStyles(
                props,
                staticConfig,
                defaultTheme,
                "",
                componentState,
                {
                  ...styleProps,
                  noClassNames: !0,
                  fallbackProps: completeProps
                },
                void 0,
                void 0,
                void 0,
                debugPropValue || shouldPrintDebug
              ), outProps = {
                ...includeProps ? out.viewProps : {},
                ...out.style,
                ...out.pseudos
              };
              return shouldPrintDebug && (logger.info(`(${debugName})`), logger.info(`
       getProps (props in): ${logLines(objToStr(props))}`), logger.info(`
       getProps (outProps): ${logLines(objToStr(outProps))}`)), out.fontFamily && (setPropsToFontFamily(outProps, out.fontFamily), shouldPrintDebug && logger.info(`
      \u{1F4AC} new font fam: ${out.fontFamily}`)), outProps;
            } catch (err) {
              return logger.info(["error", err.message, err.stack].join(" ")), {};
            }
          };
          shouldFlatten && attrs.unshift({
            type: "style",
            value: defaultProps
          }), attrs = attrs.reduce((acc, cur) => {
            if (cur.type === "style") {
              const key = Object.keys(cur.value)[0], value = cur.value[key];
              if (
                // !isStyleAndAttr[key] &&
                !shouldFlatten && // de-opt if non-style
                !validStyles[key] && !pseudoDescriptors[key] && !(key.startsWith("data-") || key.startsWith("aria-"))
              )
                return shouldPrintDebug && logger.info(["     - keeping as non-style", key].join(" ")), prev = cur, acc.push({
                  type: "attr",
                  value: t.jsxAttribute(
                    t.jsxIdentifier(key),
                    t.jsxExpressionContainer(
                      typeof value == "string" ? t.stringLiteral(value) : literalToAst(value)
                    )
                  )
                }), acc.push(cur), acc;
              if (prev?.type === "style")
                return mergeStyles2(prev.value, cur.value), acc;
            }
            return prev = cur, acc.push(cur), acc;
          }, []), shouldPrintDebug && logger.info(
            [
              `  - attrs (combined \u{1F500}): 
`,
              logLines(attrs.map(attrStr).join(", "))
            ].join(" ")
          );
          let getStyleError = null;
          for (const attr of attrs)
            try {
              switch (shouldPrintDebug && console.log(`  Processing ${attr.type}:`), attr.type) {
                case "ternary": {
                  const a = getProps(attr.value.alternate, !1, "ternary.alternate"), c = getProps(attr.value.consequent, !1, "ternary.consequent");
                  a && (attr.value.alternate = a), c && (attr.value.consequent = c), shouldPrintDebug && logger.info(["     => tern ", attrStr(attr)].join(" "));
                  continue;
                }
                case "style": {
                  const styles = getProps(attr.value, !1, "style");
                  styles && (attr.value = styles), shouldPrintDebug && logger.info(["  * styles (in)", logLines(objToStr(attr.value))].join(" ")), shouldPrintDebug && logger.info(["  * styles (out)", logLines(objToStr(styles))].join(" "));
                  continue;
                }
                case "attr":
                  if (shouldFlatten && t.isJSXAttribute(attr.value)) {
                    const key = attr.value.name.name;
                    if (key === "style" || key === "className" || key === "tag")
                      continue;
                    const value = attemptEvalSafe(
                      attr.value.value || t.booleanLiteral(!0)
                    );
                    if (value !== FAILED_EVAL) {
                      const outProps = getProps({ [key]: value }, !0, `attr.${key}`), outKey = Object.keys(outProps)[0];
                      if (outKey) {
                        const outVal = outProps[outKey];
                        attr.value = t.jsxAttribute(
                          t.jsxIdentifier(outKey),
                          t.jsxExpressionContainer(
                            typeof outVal == "string" ? t.stringLiteral(outVal) : literalToAst(outVal)
                          )
                        );
                      }
                    }
                  }
              }
            } catch (err) {
              getStyleError = err;
            }
          if (shouldPrintDebug && logger.info([`  - attrs (ternaries/combined):
`, logLines(attrs.map(attrStr).join(", "))].join(" ")), tm.mark("jsx-element-styles", !!shouldPrintDebug), getStyleError)
            return logger.info([" \u26A0\uFE0F postprocessing error, deopt", getStyleError].join(" ")), node.attributes = ogAttributes, null;
          const existingStyleKeys = /* @__PURE__ */ new Set();
          for (let i = attrs.length - 1; i >= 0; i--) {
            const attr = attrs[i];
            if (shouldFlatten && attr.type === "attr" && t.isJSXAttribute(attr.value) && t.isJSXIdentifier(attr.value.name)) {
              const name = attr.value.name.name;
              INLINE_EXTRACTABLE[name] && (attr.value.name.name = INLINE_EXTRACTABLE[name]);
            }
            if (attr.type === "style")
              for (const key in attr.value)
                existingStyleKeys.has(key) ? (shouldPrintDebug && logger.info([`  >> delete existing ${key}`].join(" ")), delete attr.value[key]) : existingStyleKeys.add(key);
          }
          if (!shouldFlatten && inlineWhenUnflattened.size) {
            for (const [index, attr] of attrs.entries())
              if (attr.type === "style")
                for (const key in attr.value) {
                  if (!inlineWhenUnflattened.has(key))
                    continue;
                  const val = inlineWhenUnflattenedOGVals[key];
                  val ? (delete attr.value[key], attrs.splice(index - 1, 0, val.attr)) : delete attr.value[key];
                }
          }
          if (shouldFlatten && (shouldPrintDebug && logger.info(["  [\u2705] flattening", originalNodeName, flatNode].join(" ")), node.name.name = flatNode, res.flattened++, closingElement && (closingElement.name.name = flatNode)), !shouldFlatten && platform === "native")
            return shouldPrintDebug && logger.info("Disabled flattening except for simple cases on native for now"), node.attributes = ogAttributes, null;
          shouldPrintDebug && (logger.info([` - inlined props (${inlined.size}):`, shouldDeopt ? " deopted" : "", hasSpread ? " has spread" : "", staticConfig.neverFlatten ? "neverFlatten" : ""].join(" ")), logger.info(`  - shouldFlatten/isFlattened: ${shouldFlatten}`), logger.info(`  - attrs (end):
 ${logLines(attrs.map(attrStr).join(", "))}`)), onExtractTag({
            parserProps: propsWithFileInfo,
            attrs,
            node,
            lineNumbers,
            filePath,
            config: tamaguiConfig,
            attemptEval,
            jsxPath: traversePath,
            originalNodeName,
            isFlattened: shouldFlatten,
            programPath,
            completeProps,
            staticConfig
          });
        } catch (err) {
          node.attributes = ogAttributes, console.error(`@tamagui/static Error: ${err.message} ${err.stack}`);
        } finally {
          debugPropValue && (shouldPrintDebug = ogDebug);
        }
      }
    }), tm.mark("jsx-done", !!shouldPrintDebug), modifiedComponents.size) {
      const all = Array.from(modifiedComponents);
      shouldPrintDebug && logger.info(`  [\u{1FA9D}] hook check ${all.length}`);
      for (const comp of all)
        removeUnusedHooks(comp, shouldPrintDebug);
    }
    return tm.done(shouldPrintDebug === "verbose"), res;
  }
}
export {
  createExtractor
};
//# sourceMappingURL=createExtractor.js.map
