import { basename } from "path";
import generate from "@babel/generator";
import * as t from "@babel/types";
import findRoot from "find-root";
import { memoize } from "../helpers/memoize";
function isPresent(input) {
  return input != null;
}
function isSimpleSpread(node) {
  return t.isIdentifier(node.argument) || t.isMemberExpression(node.argument);
}
const attrStr = (attr) => attr ? attr.type === "attr" ? getNameAttr(attr.value) : attr.type === "ternary" ? `...${ternaryStr(attr.value)}` : `${attr.type}(${objToStr(attr.value)})` : "", objToStr = (obj, spacer = ", ") => obj ? `{${Object.entries(obj).map(
  ([k, v]) => `${k}:${Array.isArray(v) ? "[...]" : v && typeof v == "object" ? `${objToStr(v, ",")}` : JSON.stringify(v)}`
).join(spacer)}}` : `${obj}`, getNameAttr = (attr) => t.isJSXSpreadAttribute(attr) ? `...${attr.argument.name}` : "name" in attr ? attr.name.name : `unknown-${attr.type}`, ternaryStr = (x) => [
  "ternary(",
  t.isIdentifier(x.test) ? x.test.name : t.isMemberExpression(x.test) ? [x.test.object.name, x.test.property.name] : (
    // @ts-ignore
    generate(x.test).code
  ),
  isFilledObj(x.consequent) ? ` ? ${objToStr(x.consequent)}` : " ? \u{1F6AB}",
  isFilledObj(x.alternate) ? ` : ${objToStr(x.alternate)}` : " : \u{1F6AB}",
  ")"
].flat().join(""), isFilledObj = (obj) => obj && Object.keys(obj).length;
function findComponentName(scope) {
  const componentName = "";
  let cur = scope.path;
  for (; cur.parentPath && !t.isProgram(cur.parentPath.parent); )
    cur = cur.parentPath;
  let node = cur.parent;
  if (t.isExportNamedDeclaration(node) && (node = node.declaration), t.isVariableDeclaration(node)) {
    const [dec] = node.declarations;
    if (t.isVariableDeclarator(dec) && t.isIdentifier(dec.id))
      return dec.id.name;
  }
  return t.isFunctionDeclaration(node) ? node.id?.name : componentName;
}
function isValidThemeHook(props, jsxPath, n, sourcePath) {
  if (!t.isIdentifier(n.object) || !t.isIdentifier(n.property))
    return !1;
  const binding = jsxPath.scope.getAllBindings()[n.object.name];
  if (!binding?.path || !binding.path.isVariableDeclarator())
    return !1;
  const init = binding.path.node.init;
  if (!init || !t.isCallExpression(init) || !t.isIdentifier(init.callee) || init.callee.name !== "useTheme")
    return !1;
  const importNode = binding.scope.getBinding("useTheme")?.path.parent;
  return !(!t.isImportDeclaration(importNode) || sourcePath && !isValidImport(props, sourcePath));
}
const isInsideComponentPackage = (props, moduleName) => getValidComponentsPaths(props).some((path) => moduleName.startsWith(path)), isComponentPackage = (props, srcName) => getValidComponentsPaths(props).some((path) => srcName.startsWith(path));
function getValidComponent(props, moduleName, componentName) {
  if (componentName[0].toUpperCase() !== componentName[0])
    return !1;
  for (const loaded of props.allLoadedComponents) {
    if (!loaded)
      continue;
    const isInModule = moduleName === "*" || moduleName.startsWith(loaded.moduleName), foundComponent = loaded.nameToInfo[componentName];
    if (isInModule && foundComponent)
      return foundComponent;
  }
  return null;
}
const isValidModule = (props, moduleName) => {
  if (typeof moduleName != "string")
    throw new Error("No module name");
  const isLocal = moduleName.startsWith(".");
  return {
    isLocal,
    isValid: isLocal ? isInsideComponentPackage(props, moduleName) : isComponentPackage(props, moduleName)
  };
}, getValidImport = (props, moduleName, componentName) => {
  const { isValid, isLocal } = isValidModule(props, moduleName);
  return !isValid || !componentName ? null : getValidComponent(props, isLocal ? "*" : moduleName, componentName) || null;
}, isValidImport = (props, moduleName, componentName) => componentName ? !!getValidImport(props, moduleName, componentName) : isValidModule(props, moduleName).isValid, getValidComponentPackages = memoize((props) => [.../* @__PURE__ */ new Set(["@tamagui/core", "tamagui", ...props.components])]), getValidComponentsPaths = memoize((props) => getValidComponentPackages(props).map((pkg) => {
  const root = findRoot(pkg);
  return basename(root);
}));
export {
  attrStr,
  findComponentName,
  getValidComponent,
  getValidComponentsPaths,
  getValidImport,
  isComponentPackage,
  isInsideComponentPackage,
  isPresent,
  isSimpleSpread,
  isValidImport,
  isValidModule,
  isValidThemeHook,
  objToStr,
  ternaryStr
};
//# sourceMappingURL=extractHelpers.js.map
