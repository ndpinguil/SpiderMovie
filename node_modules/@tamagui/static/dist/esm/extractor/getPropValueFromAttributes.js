import generate from "@babel/generator";
import * as t from "@babel/types";
import { accessSafe } from "./accessSafe";
function getPropValueFromAttributes(propName, attrs) {
  let propIndex = -1, jsxAttr = null;
  for (let idx = -1, len = attrs.length; ++idx < len; ) {
    const attr = attrs[idx];
    if (t.isJSXAttribute(attr) && attr.name && attr.name.name === propName) {
      propIndex = idx, jsxAttr = attr;
      break;
    }
  }
  if (!jsxAttr || jsxAttr.value == null)
    return null;
  let propValue = jsxAttr.value;
  if (t.isJSXExpressionContainer(propValue) && (propValue = propValue.expression), t.isJSXEmptyExpression(propValue))
    return console.error("encountered JSXEmptyExpression"), null;
  const applicableSpreads = attrs.filter(
    // 1. idx is greater than propValue prop index
    // 2. attr is a spread operator
    (attr, idx) => {
      if (t.isJSXSpreadAttribute(attr)) {
        if (t.isIdentifier(attr.argument) || t.isMemberExpression(attr.argument))
          return idx > propIndex;
        if (t.isLogicalExpression(attr.argument))
          return !1;
        throw new Error(
          `unsupported spread of type "${attr.argument.type}": ${// @ts-ignore
          generate(attr).code}`
        );
      }
      return !1;
    }
  ).map((attr) => attr.argument);
  return applicableSpreads.length > 0 && (propValue = applicableSpreads.reduce(
    (acc, val) => t.logicalExpression("||", accessSafe(val, propName), acc),
    propValue
  )), propValue;
}
export {
  getPropValueFromAttributes
};
//# sourceMappingURL=getPropValueFromAttributes.js.map
