import * as t from "@babel/types";
const buildClassName = (objectsIn, extras = "") => {
  let objects = buildClassNameLogic(objectsIn);
  return objects ? (t.isStringLiteral(objects) ? objects.value = `${extras} ${objects.value}` : objects = t.binaryExpression("+", t.stringLiteral(extras), objects), objects) : null;
}, buildClassNameLogic = (objects) => objects.reduce((acc, val) => {
  if (acc == null)
    return (
      // pass conditional expressions through
      t.isConditionalExpression(val) || // pass non-null literals through
      t.isStringLiteral(val) || t.isNumericLiteral(val) ? val : t.logicalExpression("||", val, t.stringLiteral(""))
    );
  let inner;
  if (t.isStringLiteral(val)) {
    if (t.isStringLiteral(acc))
      return t.stringLiteral(`${acc.value} ${val.value}`);
    inner = t.stringLiteral(` ${val.value}`);
  } else if (t.isLiteral(val))
    inner = t.binaryExpression("+", t.stringLiteral(" "), val);
  else if (t.isConditionalExpression(val) || t.isBinaryExpression(val)) {
    if (t.isStringLiteral(acc))
      return t.binaryExpression("+", t.stringLiteral(`${acc.value} `), val);
    inner = t.binaryExpression("+", t.stringLiteral(" "), val);
  } else if (t.isIdentifier(val) || t.isMemberExpression(val))
    inner = t.conditionalExpression(
      val,
      t.binaryExpression("+", t.stringLiteral(" "), val),
      t.stringLiteral("")
    );
  else {
    if (t.isStringLiteral(acc))
      return t.binaryExpression(
        "+",
        t.stringLiteral(`${acc.value} `),
        t.logicalExpression("||", val, t.stringLiteral(""))
      );
    inner = t.binaryExpression(
      "+",
      t.stringLiteral(" "),
      t.logicalExpression("||", val, t.stringLiteral(""))
    );
  }
  return t.binaryExpression("+", acc, inner);
}, null);
export {
  buildClassName,
  buildClassNameLogic
};
//# sourceMappingURL=buildClassName.js.map
