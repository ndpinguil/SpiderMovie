import { readFileSync } from "fs";
import { basename, dirname, extname, join, relative, sep } from "path";
import generate from "@babel/generator";
import traverse from "@babel/traverse";
import * as t from "@babel/types";
import { Color, colorLog } from "@tamagui/cli-color";
import esbuild from "esbuild";
import { ensureDir, removeSync, writeFileSync } from "fs-extra";
import { registerRequire, setRequireResult } from "../registerRequire";
import { babelParse } from "./babelParse";
import { bundle } from "./bundle";
import { getTamaguiConfigPathFromOptionsConfig } from "./getTamaguiConfigPathFromOptionsConfig";
const external = [
  "@tamagui/core",
  "@tamagui/web",
  "react",
  "react-dom",
  "react-native-svg"
], esbuildExtraOptions = {
  define: {
    __DEV__: `${process.env.NODE_ENV === "development"}`
  }
}, esbuildOptions = {
  target: "es2018",
  format: "cjs",
  jsx: "transform",
  platform: "node",
  ...esbuildExtraOptions
};
let currentBundle = null, isBundling = !1, lastBundle = null;
const waitForBundle = /* @__PURE__ */ new Set();
function hasBundledConfigChanged() {
  return lastBundle === currentBundle ? !1 : (lastBundle = currentBundle, !0);
}
async function getBundledConfig(props, rebuild = !1) {
  if (isBundling)
    await new Promise((res) => {
      waitForBundle.add(res);
    });
  else if (!currentBundle || rebuild)
    return await bundleConfig(props);
  return currentBundle;
}
async function bundleConfig(props) {
  try {
    isBundling = !0;
    const configEntry = props.config ? getTamaguiConfigPathFromOptionsConfig(props.config) : "", tmpDir = join(process.cwd(), ".tamagui"), configOutPath = join(tmpDir, "tamagui.config.cjs"), baseComponents = props.components.filter((x) => x !== "@tamagui/core"), componentOutPaths = baseComponents.map(
      (componentModule) => join(
        tmpDir,
        `${componentModule.split(sep).join("-").replace(/[^a-z0-9]+/gi, "")}-components.config.cjs`
      )
    );
    process.env.NODE_ENV === "development" && process.env.DEBUG?.startsWith("tamagui") && console.log("Building config entry", configEntry);
    try {
      await ensureDir(tmpDir);
    } catch {
    }
    const start = Date.now();
    await Promise.all([
      props.config ? bundle(
        {
          entryPoints: [configEntry],
          external,
          outfile: configOutPath,
          target: "node16",
          ...esbuildExtraOptions
        },
        props.platform
      ) : null,
      ...baseComponents.map((componentModule, i) => bundle(
        {
          entryPoints: [componentModule],
          resolvePlatformSpecificEntries: !0,
          external,
          outfile: componentOutPaths[i],
          target: "node16",
          ...esbuildExtraOptions
        },
        props.platform
      ))
    ]), colorLog(
      Color.FgYellow,
      `
    \u27A1 [tamagui] (${Date.now() - start}ms):`
    ), colorLog(
      Color.Dim,
      `
        Config     .${sep}${relative(process.cwd(), configOutPath)}
        Components ${[
        ...componentOutPaths.map((p) => `.${sep}${relative(process.cwd(), p)}`)
      ].join(`
             `)}
        `
    );
    let out;
    const { unregister } = registerRequire(props.platform);
    try {
      out = require(configOutPath);
    } catch (err) {
      throw err;
    } finally {
      unregister();
    }
    let config = out.default || out || out.config;
    if (config && config.config && !config.tokens && (config = config.config), !config)
      throw new Error(`No config: ${config}`);
    let components = loadComponents({
      ...props,
      components: componentOutPaths
    });
    if (!components)
      throw new Error(`No components found: ${componentOutPaths.join(", ")}`);
    for (const component of components)
      component.moduleName = baseComponents[componentOutPaths.indexOf(component.moduleName)], component.moduleName || (process.env.DEBUG?.includes("tamagui") || process.env.IS_TAMAGUI_DEV) && console.warn(
        `\u26A0\uFE0F no module name found: ${component.moduleName} ${JSON.stringify(
          baseComponents
        )} in ${JSON.stringify(componentOutPaths)}`
      );
    const coreComponents = loadComponents({
      ...props,
      components: ["@tamagui/core"]
    });
    coreComponents && (coreComponents[0].moduleName = "@tamagui/core", components = [...components, ...coreComponents]), process.env.NODE_ENV === "development" && process.env.DEBUG?.startsWith("tamagui") && console.log("Loaded components", components);
    const res = {
      components,
      nameToPaths: {},
      tamaguiConfig: config
    };
    return currentBundle = res, res;
  } catch (err) {
    console.error(
      `Error bundling tamagui config: ${err?.message} (run with DEBUG=tamagui to see stack)`
    ), process.env.DEBUG?.includes("tamagui") && console.error(err.stack);
  } finally {
    isBundling = !1, waitForBundle.forEach((cb) => cb()), waitForBundle.clear();
  }
}
function loadComponents(props, forceExports = !1) {
  const componentsModules = props.components, key = componentsModules.join("");
  if (!forceExports && cacheComponents[key])
    return cacheComponents[key];
  const { unregister } = registerRequire(props.platform, {
    proxyWormImports: forceExports
  });
  try {
    const info = componentsModules.flatMap((name) => {
      const isDynamic = !!extname(name) && forceExports, fileContents = isDynamic ? readFileSync(name, "utf-8") : "", loadModule = isDynamic ? join(dirname(name), `.tamagui-dynamic-eval-${basename(name)}.tsx`) : name;
      let writtenContents = fileContents, didBabel = !1;
      function attemptLoad({ forceExports: forceExports2 = !1 } = {}) {
        isDynamic && (writtenContents = forceExports2 ? transformAddExports(babelParse(esbuildit(fileContents, "modern"), name)) : fileContents, writeFileSync(loadModule, writtenContents), esbuild.buildSync({
          ...esbuildOptions,
          entryPoints: [loadModule],
          outfile: loadModule,
          alias: {
            "react-native": require.resolve("@tamagui/react-native-prebuilt")
          },
          bundle: !0,
          packages: "external",
          allowOverwrite: !0,
          // logLevel: 'silent',
          sourcemap: !1,
          loader: {
            ".png": "dataurl",
            ".jpg": "dataurl",
            ".jpeg": "dataurl",
            ".gif": "dataurl"
          }
        })), process.env.DEBUG === "tamagui" && console.log("loadModule", loadModule, require.resolve(loadModule));
        const moduleResult = require(loadModule);
        forceExports2 || setRequireResult(name, moduleResult);
        const nameToInfo = getComponentStaticConfigByName(
          name,
          interopDefaultExport(moduleResult)
        );
        return {
          moduleName: name,
          nameToInfo
        };
      }
      const dispose = () => {
        isDynamic && removeSync(loadModule);
      };
      try {
        const res = attemptLoad({
          forceExports: !0
        });
        return didBabel = !0, res;
      } catch (err) {
        console.log("babel err", err, writtenContents), writtenContents = fileContents, process.env.DEBUG?.startsWith("tamagui") && console.log("Error parsing babel likely", err);
      } finally {
        dispose();
      }
      try {
        return attemptLoad({
          forceExports: !1
        });
      } catch (err) {
        return process.env.TAMAGUI_ENABLE_WARN_DYNAMIC_LOAD && (console.log(`

Tamagui attempted but failed to dynamically optimize components in:
  ${name}
`), console.log(err), console.log(
          `At: ${loadModule}`,
          `
didBabel: ${didBabel}`,
          `
In:`,
          writtenContents,
          `
isDynamic: `,
          isDynamic
        )), [];
      } finally {
        dispose();
      }
    });
    return cacheComponents[key] = info, info;
  } catch (err) {
    return console.log("Tamagui error bundling components", err.message, err.stack), null;
  } finally {
    unregister();
  }
}
const esbuildit = (src, target) => esbuild.transformSync(src, {
  ...esbuildOptions,
  ...target === "modern" && {
    target: "es2022",
    jsx: "transform",
    loader: "tsx",
    platform: "neutral",
    format: "esm"
  }
}).code;
function getComponentStaticConfigByName(name, exported) {
  const components = {};
  try {
    if (!exported || typeof exported != "object" || Array.isArray(exported))
      throw new Error(`Invalid export from package ${name}: ${typeof exported}`);
    for (const key in exported) {
      const found = getTamaguiComponent(key, exported[key]);
      if (found) {
        const { Component, ...sc } = found.staticConfig;
        components[key] = { staticConfig: sc };
      }
    }
  } catch (err) {
    process.env.TAMAGUI_ENABLE_WARN_DYNAMIC_LOAD && (console.error(
      `Tamagui failed getting components from ${name} (Disable error by setting environment variable TAMAGUI_ENABLE_WARN_DYNAMIC_LOAD=1)`
    ), console.error(err));
  }
  return components;
}
function getTamaguiComponent(name, Component) {
  if (name[0].toUpperCase() !== name[0])
    return;
  if (Component?.staticConfig)
    return Component;
}
function interopDefaultExport(mod) {
  return mod?.default ?? mod;
}
const cacheComponents = {};
function transformAddExports(ast) {
  const usedNames = /* @__PURE__ */ new Set();
  return traverse(ast, {
    ExportNamedDeclaration(nodePath) {
      if (nodePath.node.specifiers)
        for (const spec of nodePath.node.specifiers)
          usedNames.add(
            t.isIdentifier(spec.exported) ? spec.exported.name : spec.exported.value
          );
    }
  }), traverse(ast, {
    VariableDeclaration(nodePath) {
      if (!t.isProgram(nodePath.parent))
        return;
      const decs = nodePath.node.declarations;
      if (decs.length > 1)
        return;
      const [dec] = decs;
      t.isIdentifier(dec.id) && dec.init && (usedNames.has(dec.id.name) || (usedNames.add(dec.id.name), nodePath.replaceWith(
        t.exportNamedDeclaration(t.variableDeclaration("let", [dec]), [
          t.exportSpecifier(t.identifier(dec.id.name), t.identifier(dec.id.name))
        ])
      )));
    }
  }), generate(ast, {
    concise: !1,
    filename: "test.tsx",
    retainLines: !1,
    sourceMaps: !1
  }).code;
}
export {
  bundleConfig,
  esbuildOptions,
  getBundledConfig,
  hasBundledConfigChanged,
  loadComponents
};
//# sourceMappingURL=bundleConfig.js.map
