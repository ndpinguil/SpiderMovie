import { createCollection } from "@tamagui/collection";
import { useComposedRefs } from "@tamagui/compose-refs";
import {
  Stack,
  composeEventHandlers,
  isWeb,
  useEvent,
  withStaticProperties
} from "@tamagui/core";
import { createContextScope } from "@tamagui/create-context";
import { useControllableState } from "@tamagui/use-controllable-state";
import { useDirection } from "@tamagui/use-direction";
import * as React from "react";
const ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
const EVENT_OPTIONS = { bubbles: false, cancelable: true };
const RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    ...groupProps
  } = props;
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);
  const handleEntryFocus = useEvent(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = React.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return <RovingFocusProvider
    scope={__scopeRovingFocusGroup}
    orientation={orientation}
    dir={direction}
    loop={loop}
    currentTabStopId={currentTabStopId}
    onItemFocus={React.useCallback(
      (tabStopId) => setCurrentTabStopId(tabStopId),
      [setCurrentTabStopId]
    )}
    onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}
    onFocusableItemAdd={React.useCallback(
      () => setFocusableItemsCount((prevCount) => prevCount + 1),
      []
    )}
    onFocusableItemRemove={React.useCallback(
      () => setFocusableItemsCount((prevCount) => prevCount - 1),
      []
    )}
  ><Stack
    tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}
    data-orientation={orientation}
    {...groupProps}
    ref={composedRefs}
    style={[{ outline: "none" }, props.style]}
    onMouseDown={composeEventHandlers(props.onMouseDown, () => {
      isClickFocusRef.current = true;
    })}
    onFocus={composeEventHandlers(props.onFocus, (event) => {
      const isKeyboardFocus = !isClickFocusRef.current;
      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().filter((item) => item.focusable);
          const activeItem = items.find((item) => item.active);
          const currentItem = items.find((item) => item.id === currentTabStopId);
          const candidateItems = [activeItem, currentItem, ...items].filter(
            Boolean
          );
          const candidateNodes = candidateItems.map((item) => item.ref.current);
          focusFirst(candidateNodes);
        }
      }
      isClickFocusRef.current = false;
    })}
    onBlur={composeEventHandlers(
      props.onBlur,
      () => setIsTabbingBackOut(false)
    )}
  /></RovingFocusProvider>;
});
const ITEM_NAME = "RovingFocusGroupItem";
const RovingFocusGroupItem = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    focusable = true,
    active = false,
    tabStopId,
    ...itemProps
  } = props;
  const autoId = React.useId();
  const id = tabStopId || autoId;
  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove } = context;
  React.useEffect(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
  return <Collection.ItemSlot
    scope={__scopeRovingFocusGroup}
    id={id}
    focusable={focusable}
    active={active}
  ><Stack
    tabIndex={isCurrentTabStop ? 0 : -1}
    data-orientation={context.orientation}
    {...itemProps}
    ref={forwardedRef}
    onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {
      if (!focusable)
        event.preventDefault();
      else
        context.onItemFocus(id);
    })}
    onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}
    {...isWeb && {
      onKeyDown: composeEventHandlers(
        props.onKeyDown,
        (event) => {
          if (event.key === "Tab" && event.shiftKey) {
            context.onItemShiftTab();
            return;
          }
          if (event.target !== event.currentTarget)
            return;
          const focusIntent = getFocusIntent(event, context.orientation, context.dir);
          if (focusIntent !== void 0) {
            event.preventDefault();
            const items = getItems().filter((item) => item.focusable);
            let candidateNodes = items.map((item) => item.ref.current);
            if (focusIntent === "last")
              candidateNodes.reverse();
            else if (focusIntent === "prev" || focusIntent === "next") {
              if (focusIntent === "prev")
                candidateNodes.reverse();
              const currentIndex = candidateNodes.indexOf(event.currentTarget);
              candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
            }
            setTimeout(() => focusFirst(candidateNodes));
          }
        }
      )
    }}
  /></Collection.ItemSlot>;
});
RovingFocusGroupItem.displayName = ITEM_NAME;
const GROUP_NAME = "RovingFocusGroup";
const [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);
const [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope]
);
const [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
const RovingFocusGroup = withStaticProperties(
  React.forwardRef(
    (props, forwardedRef) => {
      return <Collection.Provider scope={props.__scopeRovingFocusGroup}><Collection.Slot scope={props.__scopeRovingFocusGroup}><RovingFocusGroupImpl {...props} ref={forwardedRef} /></Collection.Slot></Collection.Provider>;
    }
  ),
  {
    Item: RovingFocusGroupItem
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
const MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
export {
  RovingFocusGroup,
  createRovingFocusGroupScope
};
//# sourceMappingURL=RovingFocusGroup.mjs.map
