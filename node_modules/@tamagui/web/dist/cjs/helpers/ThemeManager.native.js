"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var ThemeManager_exports = {};
__export(ThemeManager_exports, {
  ThemeManager: () => ThemeManager,
  getHasThemeUpdatingProps: () => getHasThemeUpdatingProps,
  getNonComponentParentManager: () => getNonComponentParentManager
});
module.exports = __toCommonJS(ThemeManager_exports);
var import_constants = require("@tamagui/constants"), import_config = require("../config"), import_constants2 = require("../constants/constants");
const emptyState = { name: "" };
function getHasThemeUpdatingProps(props) {
  return props.name || props.componentName || props.inverse || props.reset;
}
let uid = 0;
class ThemeManager {
  constructor(props = {}, parentManagerIn) {
    this.props = props;
    this.id = uid++;
    this.isComponent = !1;
    this.themeListeners = /* @__PURE__ */ new Set();
    this.parentManager = null;
    this.state = emptyState;
    this.scheme = null;
    this._allKeys = null;
    if (parentManagerIn === "root") {
      this.updateStateFromProps(props, !1);
      return;
    }
    if (!parentManagerIn)
      throw process.env.NODE_ENV !== "production" ? new Error(
        "No parent manager given, this is likely due to duplicated Tamagui dependencies. Check your lockfile for mis-matched versions. It could also be from an error somewhere else in your stack causing Tamagui to recieve undefined context, you can try putting some ErrorBoundary components around other areas of your app, or a Suspense boundary."
      ) : "\u274C 0";
    if (this.parentManager = parentManagerIn, !this.updateStateFromProps(props, !1))
      return parentManagerIn || this;
  }
  updateStateFromProps(props = this.props || {}, shouldNotify = !0) {
    if (this.props = props, props.forceTheme)
      return this.state.theme = props.forceTheme, this.state.name = props.name || "", !0;
    const nextState = this.getStateIfChanged(props);
    if (nextState)
      return this.updateState(nextState, shouldNotify), nextState;
  }
  updateState(nextState, shouldNotify = !0) {
    this.state = nextState;
    const names = this.state.name.split("_"), lastName = names[names.length - 1][0];
    this.isComponent = lastName[0] === lastName[0].toUpperCase(), this._allKeys = null, this.scheme = names[0] === "light" ? "light" : names[0] === "dark" ? "dark" : null, process.env.NODE_ENV === "development" && (this._numChangeEventsSent ??= 0, this._numChangeEventsSent++), shouldNotify && queueMicrotask(() => {
      this.notify();
    });
  }
  getStateIfChanged(props = this.props, state = this.state, parentManager = this.parentManager) {
    const _ = this.getState(props, parentManager);
    if (state && state !== emptyState && !_)
      return parentManager == null ? void 0 : parentManager.state;
    if (this.getStateShouldChange(_, state))
      return _;
  }
  getStateShouldChange(nextState, state = this.state) {
    return !(!(nextState != null && nextState.theme) || nextState.theme === (state == null ? void 0 : state.theme));
  }
  getState(props = this.props, parentManager = this.parentManager) {
    return getState(props, parentManager) || (parentManager == null ? void 0 : parentManager.state) || null;
  }
  get allKeys() {
    var _a;
    return this._allKeys ||= /* @__PURE__ */ new Set([
      ...((_a = this.parentManager) == null ? void 0 : _a.allKeys) || [],
      ...Object.keys(this.state.theme || {})
    ]), this._allKeys;
  }
  notify(forced = !1) {
    this.themeListeners.forEach((cb) => cb(this.state.name, this, forced));
  }
  onChangeTheme(cb, debugId) {
    return process.env.NODE_ENV === "development" && debugId && (this._listeningIds ??= /* @__PURE__ */ new Set(), this._listeningIds.add(debugId)), this.themeListeners.add(cb), () => {
      this.themeListeners.delete(cb);
    };
  }
}
function getNextThemeClassName(name) {
  return `t_sub_theme ${import_constants2.THEME_CLASSNAME_PREFIX}${name}`.replace("light_", "").replace("dark_", "");
}
function getState(props, parentManager) {
  var _a, _b, _c, _d, _e, _f;
  const validManagerAndAllComponentThemes = getNonComponentParentManager(parentManager);
  parentManager = validManagerAndAllComponentThemes[0];
  const allComponentThemes = validManagerAndAllComponentThemes[1], themes = (0, import_config.getThemes)(), isDirectParentAComponentTheme = allComponentThemes.length > 0;
  if (props.name && props.reset)
    throw new Error("Cannot reset + set new name");
  if (!props.name && !props.inverse && !props.reset && !props.componentName)
    return null;
  if (props.reset && !isDirectParentAComponentTheme && !(parentManager != null && parentManager.parentManager))
    return process.env.NODE_ENV === "development" && console.warn("Cannot reset no grandparent exists"), null;
  let result = null;
  const nextName = props.reset ? isDirectParentAComponentTheme ? ((_a = parentManager == null ? void 0 : parentManager.state) == null ? void 0 : _a.name) || "" : ((_c = (_b = parentManager == null ? void 0 : parentManager.parentManager) == null ? void 0 : _b.state) == null ? void 0 : _c.name) || "" : props.name || "", { componentName } = props, parentName = props.reset ? isDirectParentAComponentTheme ? (
    // here because parentManager already skipped componentTheme so we have to only go up once
    ((_d = parentManager == null ? void 0 : parentManager.parentManager) == null ? void 0 : _d.state.name) || ""
  ) : ((_f = (_e = parentManager == null ? void 0 : parentManager.parentManager) == null ? void 0 : _e.parentManager) == null ? void 0 : _f.state.name) || "" : isDirectParentAComponentTheme ? allComponentThemes[0] || "" : (parentManager == null ? void 0 : parentManager.state.name) || "";
  props.reset && isDirectParentAComponentTheme && allComponentThemes.shift();
  const base = parentName.split(import_constants2.THEME_NAME_SEPARATOR), lastSegment = base[base.length - 1], isParentComponentTheme = parentName && lastSegment[0].toUpperCase() === lastSegment[0];
  isParentComponentTheme && base.pop();
  const parentBaseTheme = isParentComponentTheme ? base.slice(0, base.length).join(import_constants2.THEME_NAME_SEPARATOR) : parentName, max = base.length, min = componentName && !nextName ? max : 0;
  process.env.NODE_ENV === "development" && typeof props.debug == "string" && (console.groupCollapsed("ThemeManager.getState()"), console.log({
    props,
    parentName,
    parentBaseTheme,
    base,
    min,
    max,
    isParentComponentTheme
  }));
  for (let i = max; i >= min; i--) {
    let prefix = base.slice(0, i).join(import_constants2.THEME_NAME_SEPARATOR);
    props.inverse && (prefix = inverseThemeName(prefix));
    let potentials = [];
    if (prefix && prefix !== parentBaseTheme && potentials.push(prefix), nextName && potentials.unshift(prefix ? `${prefix}_${nextName}` : nextName), i === 1) {
      const lastSegment2 = potentials.findIndex((x) => !x.includes("_"));
      lastSegment2 > 0 && potentials.splice(lastSegment2, 0, nextName);
    }
    if (componentName) {
      let componentPotentials = [];
      if (nextName) {
        const beforeSeparator = prefix.slice(0, prefix.indexOf(import_constants2.THEME_NAME_SEPARATOR));
        componentPotentials.push(`${beforeSeparator}_${nextName}_${componentName}`);
      }
      if (componentPotentials.push(`${prefix}_${componentName}`), nextName) {
        const prefixLessOne = base.slice(0, i - 1).join(import_constants2.THEME_NAME_SEPARATOR);
        if (prefixLessOne) {
          const lessSpecific = `${prefixLessOne}_${nextName}_${componentName}`;
          componentPotentials.unshift(lessSpecific);
        }
        const moreSpecific = `${prefix}_${nextName}_${componentName}`;
        componentPotentials.unshift(moreSpecific);
      }
      potentials = [...componentPotentials, ...potentials, ...allComponentThemes];
    }
    const found = potentials.find((t) => t in themes);
    if (process.env.NODE_ENV === "development" && typeof props.debug == "string" && console.log(" - ", { found, potentials, parentManager }), found) {
      result = {
        name: found,
        theme: themes[found],
        className: import_constants.isWeb ? getNextThemeClassName(found) : "",
        parentName,
        componentName,
        inverse: props.inverse
      };
      break;
    }
  }
  return process.env.NODE_ENV === "development" && typeof props.debug == "string" && typeof window < "u" && (console.warn("ThemeManager.getState():", {
    result
  }), console.trace(), console.groupEnd()), result;
}
const inverseThemeName = (themeName) => themeName.startsWith("light") ? themeName.replace(/^light/, "dark") : themeName.replace(/^dark/, "light");
function getNonComponentParentManager(themeManager) {
  var _a;
  let res = themeManager, componentThemeNames = [];
  for (; res && (res != null && res.isComponent); )
    componentThemeNames.push((_a = res == null ? void 0 : res.state) == null ? void 0 : _a.name), res = res.parentManager;
  return [res || null, componentThemeNames];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ThemeManager,
  getHasThemeUpdatingProps,
  getNonComponentParentManager
});
//# sourceMappingURL=ThemeManager.js.map
