import { isWeb } from "@tamagui/constants";
import { getThemes } from "../config";
import { THEME_CLASSNAME_PREFIX, THEME_NAME_SEPARATOR } from "../constants/constants";
const emptyState = { name: "" };
function getHasThemeUpdatingProps(props) {
  return props.name || props.componentName || props.inverse || props.reset;
}
let uid = 0;
class ThemeManager {
  constructor(props = {}, parentManagerIn) {
    this.props = props;
    if (parentManagerIn === "root") {
      this.updateStateFromProps(props, !1);
      return;
    }
    if (!parentManagerIn)
      throw process.env.NODE_ENV !== "production" ? new Error(
        "No parent manager given, this is likely due to duplicated Tamagui dependencies. Check your lockfile for mis-matched versions. It could also be from an error somewhere else in your stack causing Tamagui to recieve undefined context, you can try putting some ErrorBoundary components around other areas of your app, or a Suspense boundary."
      ) : "\u274C 0";
    if (this.parentManager = parentManagerIn, !this.updateStateFromProps(props, !1))
      return parentManagerIn || this;
  }
  id = uid++;
  isComponent = !1;
  themeListeners = /* @__PURE__ */ new Set();
  parentManager = null;
  state = emptyState;
  scheme = null;
  updateStateFromProps(props = this.props || {}, shouldNotify = !0) {
    if (this.props = props, props.forceTheme)
      return this.state.theme = props.forceTheme, this.state.name = props.name || "", !0;
    const nextState = this.getStateIfChanged(props);
    if (nextState)
      return this.updateState(nextState, shouldNotify), nextState;
  }
  updateState(nextState, shouldNotify = !0) {
    this.state = nextState;
    const names = this.state.name.split("_"), lastName = names[names.length - 1][0];
    this.isComponent = lastName[0] === lastName[0].toUpperCase(), this._allKeys = null, this.scheme = names[0] === "light" ? "light" : names[0] === "dark" ? "dark" : null, process.env.NODE_ENV === "development" && (this._numChangeEventsSent ??= 0, this._numChangeEventsSent++), shouldNotify && queueMicrotask(() => {
      this.notify();
    });
  }
  getStateIfChanged(props = this.props, state = this.state, parentManager = this.parentManager) {
    const _ = this.getState(props, parentManager);
    if (state && state !== emptyState && !_)
      return parentManager?.state;
    if (this.getStateShouldChange(_, state))
      return _;
  }
  getStateShouldChange(nextState, state = this.state) {
    return !(!nextState?.theme || nextState.theme === state?.theme);
  }
  getState(props = this.props, parentManager = this.parentManager) {
    return getState(props, parentManager) || null;
  }
  _allKeys = null;
  get allKeys() {
    return this._allKeys ||= /* @__PURE__ */ new Set([
      ...this.parentManager?.allKeys || [],
      ...Object.keys(this.state.theme || {})
    ]), this._allKeys;
  }
  notify(forced = !1) {
    this.themeListeners.forEach((cb) => cb(this.state.name, this, forced));
  }
  onChangeTheme(cb, debugId) {
    return process.env.NODE_ENV === "development" && debugId && (this._listeningIds ??= /* @__PURE__ */ new Set(), this._listeningIds.add(debugId)), this.themeListeners.add(cb), () => {
      this.themeListeners.delete(cb);
    };
  }
}
function getNextThemeClassName(name) {
  return `t_sub_theme ${THEME_CLASSNAME_PREFIX}${name}`.replace("light_", "").replace("dark_", "");
}
function getState(props, parentManager) {
  const validManagerAndAllComponentThemes = getNonComponentParentManager(parentManager);
  parentManager = validManagerAndAllComponentThemes[0];
  const allComponentThemes = validManagerAndAllComponentThemes[1], themes = getThemes(), isDirectParentAComponentTheme = allComponentThemes.length > 0;
  if (props.name && props.reset)
    throw new Error("Cannot reset + set new name");
  if (!props.name && !props.inverse && !props.reset && !props.componentName)
    return null;
  if (props.reset && !isDirectParentAComponentTheme && !parentManager?.parentManager)
    return process.env.NODE_ENV === "development" && console.warn("Cannot reset no grandparent exists"), null;
  let result = null;
  const nextName = props.reset ? isDirectParentAComponentTheme ? parentManager?.state?.name || "" : parentManager?.parentManager?.state?.name || "" : props.name || "", { componentName } = props, parentName = props.reset ? isDirectParentAComponentTheme ? (
    // here because parentManager already skipped componentTheme so we have to only go up once
    parentManager?.parentManager?.state.name || ""
  ) : parentManager?.parentManager?.parentManager?.state.name || "" : isDirectParentAComponentTheme ? allComponentThemes[0] || "" : parentManager?.state.name || "";
  props.reset && isDirectParentAComponentTheme && allComponentThemes.shift();
  const base = parentName.split(THEME_NAME_SEPARATOR), lastSegment = base[base.length - 1], isParentComponentTheme = parentName && lastSegment[0].toUpperCase() === lastSegment[0];
  isParentComponentTheme && base.pop();
  const parentBaseTheme = isParentComponentTheme ? base.slice(0, base.length).join(THEME_NAME_SEPARATOR) : parentName, max = base.length, min = componentName && !nextName ? max : 0;
  process.env.NODE_ENV === "development" && typeof props.debug == "string" && (console.groupCollapsed("ThemeManager.getState()"), console.log({
    props,
    parentName,
    parentBaseTheme,
    base,
    min,
    max,
    isParentComponentTheme
  }));
  for (let i = max; i >= min; i--) {
    let prefix = base.slice(0, i).join(THEME_NAME_SEPARATOR);
    props.inverse && (prefix = inverseThemeName(prefix));
    let potentials = [];
    if (prefix && prefix !== parentBaseTheme && potentials.push(prefix), nextName && potentials.unshift(prefix ? `${prefix}_${nextName}` : nextName), i === 1) {
      const lastSegment2 = potentials.findIndex((x) => !x.includes("_"));
      lastSegment2 > 0 && potentials.splice(lastSegment2, 0, nextName);
    }
    if (componentName) {
      let componentPotentials = [];
      if (nextName) {
        const beforeSeparator = prefix.slice(0, prefix.indexOf(THEME_NAME_SEPARATOR));
        componentPotentials.push(`${beforeSeparator}_${nextName}_${componentName}`);
      }
      if (componentPotentials.push(`${prefix}_${componentName}`), nextName) {
        const prefixLessOne = base.slice(0, i - 1).join(THEME_NAME_SEPARATOR);
        if (prefixLessOne) {
          const lessSpecific = `${prefixLessOne}_${nextName}_${componentName}`;
          componentPotentials.unshift(lessSpecific);
        }
        const moreSpecific = `${prefix}_${nextName}_${componentName}`;
        componentPotentials.unshift(moreSpecific);
      }
      potentials = [...componentPotentials, ...potentials, ...allComponentThemes];
    }
    const found = potentials.find((t) => t in themes);
    if (process.env.NODE_ENV === "development" && typeof props.debug == "string" && console.log(" - ", { found, potentials, parentManager }), found) {
      result = {
        name: found,
        theme: themes[found],
        className: isWeb ? getNextThemeClassName(found) : "",
        parentName,
        componentName,
        inverse: props.inverse
      };
      break;
    }
  }
  return process.env.NODE_ENV === "development" && typeof props.debug == "string" && typeof window < "u" && (console.warn("ThemeManager.getState():", {
    result
  }), console.trace(), console.groupEnd()), result;
}
const inverseThemeName = (themeName) => themeName.startsWith("light") ? themeName.replace(/^light/, "dark") : themeName.replace(/^dark/, "light");
function getNonComponentParentManager(themeManager) {
  let res = themeManager, componentThemeNames = [];
  for (; res && res?.isComponent; )
    componentThemeNames.push(res?.state?.name), res = res.parentManager;
  return [res || null, componentThemeNames];
}
export {
  ThemeManager,
  getHasThemeUpdatingProps,
  getNonComponentParentManager
};
//# sourceMappingURL=ThemeManager.js.map
