"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var AnimatedImplementation_exports = {};
__export(AnimatedImplementation_exports, {
  default: () => AnimatedImplementation_default
});
module.exports = __toCommonJS(AnimatedImplementation_exports);
var import_AnimatedEvent = require("./AnimatedEvent"), import_DecayAnimation = __toESM(require("./animations/DecayAnimation")), import_SpringAnimation = __toESM(require("./animations/SpringAnimation")), import_TimingAnimation = __toESM(require("./animations/TimingAnimation")), import_createAnimatedComponent = __toESM(require("./createAnimatedComponent")), import_AnimatedAddition = __toESM(require("./nodes/AnimatedAddition")), import_AnimatedColor = __toESM(require("./nodes/AnimatedColor")), import_AnimatedDiffClamp = __toESM(require("./nodes/AnimatedDiffClamp")), import_AnimatedDivision = __toESM(require("./nodes/AnimatedDivision")), import_AnimatedInterpolation = __toESM(require("./nodes/AnimatedInterpolation")), import_AnimatedModulo = __toESM(require("./nodes/AnimatedModulo")), import_AnimatedMultiplication = __toESM(require("./nodes/AnimatedMultiplication")), import_AnimatedNode = __toESM(require("./nodes/AnimatedNode")), import_AnimatedSubtraction = __toESM(require("./nodes/AnimatedSubtraction")), import_AnimatedTracking = __toESM(require("./nodes/AnimatedTracking")), import_AnimatedValue = __toESM(require("./nodes/AnimatedValue")), import_AnimatedValueXY = __toESM(require("./nodes/AnimatedValueXY")), add = function(a, b) {
  return new import_AnimatedAddition.default(a, b);
}, subtract = function(a, b) {
  return new import_AnimatedSubtraction.default(a, b);
}, divide = function(a, b) {
  return new import_AnimatedDivision.default(a, b);
}, multiply = function(a, b) {
  return new import_AnimatedMultiplication.default(a, b);
}, modulo = function(a, modulus) {
  return new import_AnimatedModulo.default(a, modulus);
}, diffClamp = function(a, min, max) {
  return new import_AnimatedDiffClamp.default(a, min, max);
}, _combineCallbacks = function(callback, config) {
  return callback && config.onComplete ? function() {
    config.onComplete && config.onComplete(...arguments), callback && callback(...arguments);
  } : callback || config.onComplete;
}, maybeVectorAnim = function(value, config, anim) {
  if (value instanceof import_AnimatedValueXY.default) {
    var configX = { ...config }, configY = { ...config };
    for (var key in config) {
      var _config$key = config[key], x = _config$key.x, y = _config$key.y;
      x !== void 0 && y !== void 0 && (configX[key] = x, configY[key] = y);
    }
    var aX = anim(value.x, configX), aY = anim(value.y, configY);
    return parallel([aX, aY], {
      stopTogether: !1
    });
  } else if (value instanceof import_AnimatedColor.default) {
    var configR = { ...config }, configG = { ...config }, configB = { ...config }, configA = { ...config };
    for (var _key in config) {
      var _config$_key = config[_key], r = _config$_key.r, g = _config$_key.g, b = _config$_key.b, a = _config$_key.a;
      r !== void 0 && g !== void 0 && b !== void 0 && a !== void 0 && (configR[_key] = r, configG[_key] = g, configB[_key] = b, configA[_key] = a);
    }
    var aR = anim(value.r, configR), aG = anim(value.g, configG), aB = anim(value.b, configB), aA = anim(value.a, configA);
    return parallel([aR, aG, aB, aA], {
      stopTogether: !1
    });
  }
  return null;
}, spring = function spring2(value, config) {
  var _start = function(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue, singleConfig = configuration;
    singleValue.stopTracking(), configuration.toValue instanceof import_AnimatedNode.default ? singleValue.track(
      new import_AnimatedTracking.default(
        singleValue,
        configuration.toValue,
        import_SpringAnimation.default,
        singleConfig,
        callback
      )
    ) : singleValue.animate(new import_SpringAnimation.default(singleConfig), callback);
  };
  return maybeVectorAnim(value, config, spring2) || {
    start: function(callback) {
      _start(value, config, callback);
    },
    stop: function() {
      value.stopAnimation();
    },
    reset: function() {
      value.resetAnimation();
    },
    _startNativeLoop: function(iterations) {
      var singleConfig = {
        ...config,
        iterations
      };
      _start(value, singleConfig);
    },
    _isUsingNativeDriver: function() {
      return config.useNativeDriver || !1;
    }
  };
}, timing = function timing2(value, config) {
  var _start2 = function(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue, singleConfig = configuration;
    singleValue.stopTracking(), configuration.toValue instanceof import_AnimatedNode.default ? singleValue.track(
      new import_AnimatedTracking.default(
        singleValue,
        configuration.toValue,
        import_TimingAnimation.default,
        singleConfig,
        callback
      )
    ) : singleValue.animate(new import_TimingAnimation.default(singleConfig), callback);
  };
  return maybeVectorAnim(value, config, timing2) || {
    start: function(callback) {
      _start2(value, config, callback);
    },
    stop: function() {
      value.stopAnimation();
    },
    reset: function() {
      value.resetAnimation();
    },
    _startNativeLoop: function(iterations) {
      var singleConfig = {
        ...config,
        iterations
      };
      _start2(value, singleConfig);
    },
    _isUsingNativeDriver: function() {
      return config.useNativeDriver || !1;
    }
  };
}, decay = function decay2(value, config) {
  var _start3 = function(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue, singleConfig = configuration;
    singleValue.stopTracking(), singleValue.animate(new import_DecayAnimation.default(singleConfig), callback);
  };
  return maybeVectorAnim(value, config, decay2) || {
    start: function(callback) {
      _start3(value, config, callback);
    },
    stop: function() {
      value.stopAnimation();
    },
    reset: function() {
      value.resetAnimation();
    },
    _startNativeLoop: function(iterations) {
      var singleConfig = {
        ...config,
        iterations
      };
      _start3(value, singleConfig);
    },
    _isUsingNativeDriver: function() {
      return config.useNativeDriver || !1;
    }
  };
}, sequence = function(animations) {
  var current = 0;
  return {
    start: function(callback) {
      var onComplete = function onComplete2(result) {
        if (!result.finished) {
          callback && callback(result);
          return;
        }
        if (current++, current === animations.length) {
          callback && callback(result);
          return;
        }
        animations[current].start(onComplete2);
      };
      animations.length === 0 ? callback && callback({
        finished: !0
      }) : animations[current].start(onComplete);
    },
    stop: function() {
      current < animations.length && animations[current].stop();
    },
    reset: function() {
      animations.forEach((animation, idx) => {
        idx <= current && animation.reset();
      }), current = 0;
    },
    _startNativeLoop: function() {
      throw new Error(
        "Loops run using the native driver cannot contain Animated.sequence animations"
      );
    },
    _isUsingNativeDriver: function() {
      return !1;
    }
  };
}, parallel = function(animations, config) {
  var doneCount = 0, hasEnded = {}, stopTogether = !(config && config.stopTogether === !1), result = {
    start: function(callback) {
      if (doneCount === animations.length) {
        callback && callback({
          finished: !0
        });
        return;
      }
      animations.forEach((animation, idx) => {
        var cb = function(endResult) {
          if (hasEnded[idx] = !0, doneCount++, doneCount === animations.length) {
            doneCount = 0, callback && callback(endResult);
            return;
          }
          !endResult.finished && stopTogether && result.stop();
        };
        animation ? animation.start(cb) : cb({
          finished: !0
        });
      });
    },
    stop: function() {
      animations.forEach((animation, idx) => {
        !hasEnded[idx] && animation.stop(), hasEnded[idx] = !0;
      });
    },
    reset: function() {
      animations.forEach((animation, idx) => {
        animation.reset(), hasEnded[idx] = !1, doneCount = 0;
      });
    },
    _startNativeLoop: function() {
      throw new Error(
        "Loops run using the native driver cannot contain Animated.parallel animations"
      );
    },
    _isUsingNativeDriver: function() {
      return !1;
    }
  };
  return result;
}, delay = function(time) {
  return timing(new import_AnimatedValue.default(0), {
    toValue: 0,
    delay: time,
    duration: 0,
    useNativeDriver: !1
  });
}, stagger = function(time, animations) {
  return parallel(
    animations.map((animation, i) => sequence([delay(time * i), animation]))
  );
}, loop = function(animation, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$iterations = _ref.iterations, iterations = _ref$iterations === void 0 ? -1 : _ref$iterations, _ref$resetBeforeItera = _ref.resetBeforeIteration, resetBeforeIteration = _ref$resetBeforeItera === void 0 ? !0 : _ref$resetBeforeItera, isFinished = !1, iterationsSoFar = 0;
  return {
    start: function(callback) {
      var restart = function restart2(result) {
        result === void 0 && (result = {
          finished: !0
        }), isFinished || iterationsSoFar === iterations || result.finished === !1 ? callback && callback(result) : (iterationsSoFar++, resetBeforeIteration && animation.reset(), animation.start(restart2));
      };
      !animation || iterations === 0 ? callback && callback({
        finished: !0
      }) : animation._isUsingNativeDriver() ? animation._startNativeLoop(iterations) : restart();
    },
    stop: function() {
      isFinished = !0, animation.stop();
    },
    reset: function() {
      iterationsSoFar = 0, isFinished = !1, animation.reset();
    },
    _startNativeLoop: function() {
      throw new Error(
        "Loops run using the native driver cannot contain Animated.loop animations"
      );
    },
    _isUsingNativeDriver: function() {
      return animation._isUsingNativeDriver();
    }
  };
};
function forkEvent(event3, listener) {
  return event3 ? event3 instanceof import_AnimatedEvent.AnimatedEvent ? (event3.__addListener(listener), event3) : function() {
    typeof event3 == "function" && event3(...arguments), listener(...arguments);
  } : listener;
}
function unforkEvent(event3, listener) {
  event3 && event3 instanceof import_AnimatedEvent.AnimatedEvent && event3.__removeListener(listener);
}
var event = function(argMapping, config) {
  var animatedEvent = new import_AnimatedEvent.AnimatedEvent(argMapping, config);
  return animatedEvent.__isNative ? animatedEvent : animatedEvent.__getHandler();
}, AnimatedImplementation_default = {
  /**
   * Standard value class for driving animations.  Typically initialized with
   * `new Animated.Value(0);`
   *
   * See https://reactnative.dev/docs/animated#value
   */
  Value: import_AnimatedValue.default,
  /**
   * 2D value class for driving 2D animations, such as pan gestures.
   *
   * See https://reactnative.dev/docs/animatedvaluexy
   */
  ValueXY: import_AnimatedValueXY.default,
  /**
   * Value class for driving color animations.
   */
  Color: import_AnimatedColor.default,
  /**
   * Exported to use the Interpolation type in flow.
   *
   * See https://reactnative.dev/docs/animated#interpolation
   */
  Interpolation: import_AnimatedInterpolation.default,
  /**
   * Exported for ease of type checking. All animated values derive from this
   * class.
   *
   * See https://reactnative.dev/docs/animated#node
   */
  Node: import_AnimatedNode.default,
  /**
   * Animates a value from an initial velocity to zero based on a decay
   * coefficient.
   *
   * See https://reactnative.dev/docs/animated#decay
   */
  decay,
  /**
   * Animates a value along a timed easing curve. The Easing module has tons of
   * predefined curves, or you can use your own function.
   *
   * See https://reactnative.dev/docs/animated#timing
   */
  timing,
  /**
   * Animates a value according to an analytical spring model based on
   * damped harmonic oscillation.
   *
   * See https://reactnative.dev/docs/animated#spring
   */
  spring,
  /**
   * Creates a new Animated value composed from two Animated values added
   * together.
   *
   * See https://reactnative.dev/docs/animated#add
   */
  add,
  /**
   * Creates a new Animated value composed by subtracting the second Animated
   * value from the first Animated value.
   *
   * See https://reactnative.dev/docs/animated#subtract
   */
  subtract,
  /**
   * Creates a new Animated value composed by dividing the first Animated value
   * by the second Animated value.
   *
   * See https://reactnative.dev/docs/animated#divide
   */
  divide,
  /**
   * Creates a new Animated value composed from two Animated values multiplied
   * together.
   *
   * See https://reactnative.dev/docs/animated#multiply
   */
  multiply,
  /**
   * Creates a new Animated value that is the (non-negative) modulo of the
   * provided Animated value.
   *
   * See https://reactnative.dev/docs/animated#modulo
   */
  modulo,
  /**
   * Create a new Animated value that is limited between 2 values. It uses the
   * difference between the last value so even if the value is far from the
   * bounds it will start changing when the value starts getting closer again.
   *
   * See https://reactnative.dev/docs/animated#diffclamp
   */
  diffClamp,
  /**
   * Starts an animation after the given delay.
   *
   * See https://reactnative.dev/docs/animated#delay
   */
  delay,
  /**
   * Starts an array of animations in order, waiting for each to complete
   * before starting the next. If the current running animation is stopped, no
   * following animations will be started.
   *
   * See https://reactnative.dev/docs/animated#sequence
   */
  sequence,
  /**
   * Starts an array of animations all at the same time. By default, if one
   * of the animations is stopped, they will all be stopped. You can override
   * this with the `stopTogether` flag.
   *
   * See https://reactnative.dev/docs/animated#parallel
   */
  parallel,
  /**
   * Array of animations may run in parallel (overlap), but are started in
   * sequence with successive delays.  Nice for doing trailing effects.
   *
   * See https://reactnative.dev/docs/animated#stagger
   */
  stagger,
  /**
   * Loops a given animation continuously, so that each time it reaches the
   * end, it resets and begins again from the start.
   *
   * See https://reactnative.dev/docs/animated#loop
   */
  loop,
  /**
   * Takes an array of mappings and extracts values from each arg accordingly,
   * then calls `setValue` on the mapped outputs.
   *
   * See https://reactnative.dev/docs/animated#event
   */
  event,
  /**
   * Make any React component Animatable.  Used to create `Animated.View`, etc.
   *
   * See https://reactnative.dev/docs/animated#createanimatedcomponent
   */
  createAnimatedComponent: import_createAnimatedComponent.default,
  /**
   * Imperative API to attach an animated value to an event on a view. Prefer
   * using `Animated.event` with `useNativeDrive: true` if possible.
   *
   * See https://reactnative.dev/docs/animated#attachnativeevent
   */
  attachNativeEvent: import_AnimatedEvent.attachNativeEvent,
  /**
   * Advanced imperative API for snooping on animated events that are passed in
   * through props. Use values directly where possible.
   *
   * See https://reactnative.dev/docs/animated#forkevent
   */
  forkEvent,
  unforkEvent,
  /**
   * Expose Event class, so it can be used as a type for type checkers.
   */
  Event: import_AnimatedEvent.AnimatedEvent
};
//# sourceMappingURL=AnimatedImplementation.js.map
