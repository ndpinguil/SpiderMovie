"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var AnimatedEvent_exports = {};
__export(AnimatedEvent_exports, {
  AnimatedEvent: () => AnimatedEvent,
  attachNativeEvent: () => attachNativeEvent
});
module.exports = __toCommonJS(AnimatedEvent_exports);
var import_react_native_web_internals = require("react-native-web-internals"), import_NativeAnimatedHelper = __toESM(require("./NativeAnimatedHelper")), import_NativeAnimatedHelper2 = require("./NativeAnimatedHelper"), import_AnimatedValue = __toESM(require("./nodes/AnimatedValue")), __DEV__ = process.env.NODE_ENV !== "production";
function attachNativeEvent(viewRef, eventName, argMapping) {
  var eventMappings = [], traverse = (value, path) => {
    if (value instanceof import_AnimatedValue.default)
      value.__makeNative(), eventMappings.push({
        nativeEventPath: path,
        animatedValueTag: value.__getNativeTag()
      });
    else if (typeof value == "object")
      for (var _key in value)
        traverse(value[_key], path.concat(_key));
  };
  return (0, import_react_native_web_internals.invariant)(
    argMapping[0] && argMapping[0].nativeEvent,
    "Native driven events only support animated values contained inside `nativeEvent`."
  ), traverse(argMapping[0].nativeEvent, []), viewRef != null && eventMappings.forEach((mapping) => {
    import_NativeAnimatedHelper.default.API.addAnimatedEventToView(viewRef, eventName, mapping);
  }), {
    detach() {
      viewRef != null && eventMappings.forEach((mapping) => {
        import_NativeAnimatedHelper.default.API.removeAnimatedEventFromView(
          viewRef,
          eventName,
          // $FlowFixMe[incompatible-call]
          mapping.animatedValueTag
        );
      });
    }
  };
}
function validateMapping(argMapping, args) {
  var validate = (recMapping, recEvt, key) => {
    if (recMapping instanceof import_AnimatedValue.default) {
      (0, import_react_native_web_internals.invariant)(
        typeof recEvt == "number",
        "Bad mapping of event key " + key + ", should be number but got " + typeof recEvt
      );
      return;
    }
    if (typeof recEvt == "number") {
      (0, import_react_native_web_internals.invariant)(
        recMapping instanceof import_AnimatedValue.default,
        "Bad mapping of type " + typeof recMapping + " for key " + key + ", event value must map to AnimatedValue"
      );
      return;
    }
    (0, import_react_native_web_internals.invariant)(
      typeof recMapping == "object",
      "Bad mapping of type " + typeof recMapping + " for key " + key
    ), (0, import_react_native_web_internals.invariant)(
      typeof recEvt == "object",
      "Bad event of type " + typeof recEvt + " for key " + key
    );
    for (var mappingKey in recMapping)
      validate(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
  };
  (0, import_react_native_web_internals.invariant)(args.length >= argMapping.length, "Event has less arguments than mapping"), argMapping.forEach((mapping, idx) => {
    validate(mapping, args[idx], "arg" + idx);
  });
}
class AnimatedEvent {
  constructor(argMapping, config) {
    this._listeners = [], this._argMapping = argMapping, config == null && (console.warn("Animated.event now requires a second argument for options"), config = {
      useNativeDriver: !1
    }), config.listener && this.__addListener(config.listener), this._callListeners = this._callListeners.bind(this), this._attachedEvent = null, this.__isNative = (0, import_NativeAnimatedHelper2.shouldUseNativeDriver)(config);
  }
  __addListener(callback) {
    this._listeners.push(callback);
  }
  __removeListener(callback) {
    this._listeners = this._listeners.filter((listener) => listener !== callback);
  }
  __attach(viewRef, eventName) {
    (0, import_react_native_web_internals.invariant)(this.__isNative, "Only native driven events need to be attached."), this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
  }
  __detach(viewTag, eventName) {
    (0, import_react_native_web_internals.invariant)(this.__isNative, "Only native driven events need to be detached."), this._attachedEvent && this._attachedEvent.detach();
  }
  __getHandler() {
    var _this = this;
    if (this.__isNative)
      if (__DEV__) {
        var _validatedMapping = !1;
        return function() {
          for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++)
            args[_key2] = arguments[_key2];
          _validatedMapping || (validateMapping(_this._argMapping, args), _validatedMapping = !0), _this._callListeners(...args);
        };
      } else
        return this._callListeners;
    var validatedMapping = !1;
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++)
        args[_key3] = arguments[_key3];
      __DEV__ && !validatedMapping && (validateMapping(_this._argMapping, args), validatedMapping = !0);
      var traverse = (recMapping, recEvt, key) => {
        if (recMapping instanceof import_AnimatedValue.default)
          typeof recEvt == "number" && recMapping.setValue(recEvt);
        else if (typeof recMapping == "object")
          for (var mappingKey in recMapping)
            traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
      };
      _this._argMapping.forEach((mapping, idx) => {
        traverse(mapping, args[idx], "arg" + idx);
      }), _this._callListeners(...args);
    };
  }
  _callListeners() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++)
      args[_key4] = arguments[_key4];
    this._listeners.forEach((listener) => listener(...args));
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AnimatedEvent,
  attachNativeEvent
});
//# sourceMappingURL=AnimatedEvent.js.map
