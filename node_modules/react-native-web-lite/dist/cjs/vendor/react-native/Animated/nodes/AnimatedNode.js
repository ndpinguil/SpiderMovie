"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var AnimatedNode_exports = {};
__export(AnimatedNode_exports, {
  default: () => AnimatedNode_default
});
module.exports = __toCommonJS(AnimatedNode_exports);
var import_react_native_web_internals = require("react-native-web-internals"), import_NativeAnimatedHelper = __toESM(require("../NativeAnimatedHelper")), NativeAnimatedAPI = import_NativeAnimatedHelper.default.API, _uniqueId = 1;
class AnimatedNode {
  __attach() {
  }
  __detach() {
    this.__isNative && this.__nativeTag != null && (import_NativeAnimatedHelper.default.API.dropAnimatedNode(this.__nativeTag), this.__nativeTag = void 0);
  }
  __getValue() {
  }
  __getAnimatedValue() {
    return this.__getValue();
  }
  __addChild(child) {
  }
  __removeChild(child) {
  }
  __getChildren() {
    return [];
  }
  /* Methods and props used by native Animated impl */
  constructor() {
    this._listeners = {};
  }
  __makeNative(platformConfig) {
    if (!this.__isNative)
      throw new Error('This node cannot be made a "native" animated node');
    this._platformConfig = platformConfig, this.hasListeners() && this._startListeningToNativeValueUpdates();
  }
  /**
   * Adds an asynchronous listener to the value so you can observe updates from
   * animations.  This is useful because there is no way to
   * synchronously read the value because it might be driven natively.
   *
   * See https://reactnative.dev/docs/animatedvalue#addlistener
   */
  addListener(callback) {
    var id = String(_uniqueId++);
    return this._listeners[id] = callback, this.__isNative && this._startListeningToNativeValueUpdates(), id;
  }
  /**
   * Unregister a listener. The `id` param shall match the identifier
   * previously returned by `addListener()`.
   *
   * See https://reactnative.dev/docs/animatedvalue#removelistener
   */
  removeListener(id) {
    delete this._listeners[id], this.__isNative && !this.hasListeners() && this._stopListeningForNativeValueUpdates();
  }
  /**
   * Remove all registered listeners.
   *
   * See https://reactnative.dev/docs/animatedvalue#removealllisteners
   */
  removeAllListeners() {
    this._listeners = {}, this.__isNative && this._stopListeningForNativeValueUpdates();
  }
  hasListeners() {
    return !!Object.keys(this._listeners).length;
  }
  _startListeningToNativeValueUpdates() {
    this.__nativeAnimatedValueListener && !this.__shouldUpdateListenersForNewNativeTag || (this.__shouldUpdateListenersForNewNativeTag && (this.__shouldUpdateListenersForNewNativeTag = !1, this._stopListeningForNativeValueUpdates()), NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag()), this.__nativeAnimatedValueListener = import_NativeAnimatedHelper.default.nativeEventEmitter.addListener(
      "onAnimatedValueUpdate",
      (data) => {
        data.tag === this.__getNativeTag() && this.__onAnimatedValueUpdateReceived(data.value);
      }
    ));
  }
  __onAnimatedValueUpdateReceived(value) {
    this.__callListeners(value);
  }
  __callListeners(value) {
    for (var _key in this._listeners)
      this._listeners[_key]({
        value
      });
  }
  _stopListeningForNativeValueUpdates() {
    this.__nativeAnimatedValueListener && (this.__nativeAnimatedValueListener.remove(), this.__nativeAnimatedValueListener = null, NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag()));
  }
  __getNativeTag() {
    var _this$__nativeTag;
    import_NativeAnimatedHelper.default.assertNativeAnimatedModule(), (0, import_react_native_web_internals.invariant)(
      this.__isNative,
      'Attempt to get native tag from node not marked as "native"'
    );
    var nativeTag = (_this$__nativeTag = this.__nativeTag) !== null && _this$__nativeTag !== void 0 ? _this$__nativeTag : import_NativeAnimatedHelper.default.generateNewNodeTag();
    if (this.__nativeTag == null) {
      this.__nativeTag = nativeTag;
      var config = this.__getNativeConfig();
      this._platformConfig && (config.platformConfig = this._platformConfig), import_NativeAnimatedHelper.default.API.createAnimatedNode(nativeTag, config), this.__shouldUpdateListenersForNewNativeTag = !0;
    }
    return nativeTag;
  }
  __getNativeConfig() {
    throw new Error("This JS animated node type cannot be used as native animated node");
  }
  toJSON() {
    return this.__getValue();
  }
  __getPlatformConfig() {
    return this._platformConfig;
  }
  __setPlatformConfig(platformConfig) {
    this._platformConfig = platformConfig;
  }
}
var AnimatedNode_default = AnimatedNode;
//# sourceMappingURL=AnimatedNode.js.map
