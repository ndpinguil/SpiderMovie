"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var AnimatedValue_exports = {};
__export(AnimatedValue_exports, {
  default: () => AnimatedValue_default
});
module.exports = __toCommonJS(AnimatedValue_exports);
var import_react_native_web_internals = require("react-native-web-internals"), import_NativeAnimatedHelper = __toESM(require("../NativeAnimatedHelper")), import_AnimatedInterpolation = __toESM(require("./AnimatedInterpolation")), import_AnimatedWithChildren = __toESM(require("./AnimatedWithChildren")), NativeAnimatedAPI = import_NativeAnimatedHelper.default.API;
function _flush(rootNode) {
  var animatedStyles = /* @__PURE__ */ new Set();
  function findAnimatedStyles(node) {
    typeof node.update == "function" ? animatedStyles.add(node) : node.__getChildren().forEach(findAnimatedStyles);
  }
  findAnimatedStyles(rootNode), animatedStyles.forEach((animatedStyle) => animatedStyle.update());
}
function _executeAsAnimatedBatch(id, operation) {
  NativeAnimatedAPI.setWaitingForIdentifier(id), operation(), NativeAnimatedAPI.unsetWaitingForIdentifier(id);
}
class AnimatedValue extends import_AnimatedWithChildren.default {
  constructor(value, config) {
    if (super(), typeof value != "number")
      throw new Error("AnimatedValue: Attempting to set value to undefined");
    this._startingValue = this._value = value, this._offset = 0, this._animation = null, config && config.useNativeDriver && this.__makeNative();
  }
  __detach() {
    this.__isNative && NativeAnimatedAPI.getValue(this.__getNativeTag(), (value) => {
      this._value = value - this._offset;
    }), this.stopAnimation(), super.__detach();
  }
  __getValue() {
    return this._value + this._offset;
  }
  /**
   * Directly set the value.  This will stop any animations running on the value
   * and update all the bound properties.
   *
   * See https://reactnative.dev/docs/animatedvalue#setvalue
   */
  setValue(value) {
    this._animation && (this._animation.stop(), this._animation = null), this._updateValue(
      value,
      !this.__isNative
      /* don't perform a flush for natively driven values */
    ), this.__isNative && _executeAsAnimatedBatch(
      this.__getNativeTag().toString(),
      () => NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value)
    );
  }
  /**
   * Sets an offset that is applied on top of whatever value is set, whether via
   * `setValue`, an animation, or `Animated.event`.  Useful for compensating
   * things like the start of a pan gesture.
   *
   * See https://reactnative.dev/docs/animatedvalue#setoffset
   */
  setOffset(offset) {
    this._offset = offset, this.__isNative && NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
  }
  /**
   * Merges the offset value into the base value and resets the offset to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvalue#flattenoffset
   */
  flattenOffset() {
    this._value += this._offset, this._offset = 0, this.__isNative && NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
  }
  /**
   * Sets the offset value to the base value, and resets the base value to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvalue#extractoffset
   */
  extractOffset() {
    this._offset += this._value, this._value = 0, this.__isNative && NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
  }
  /**
   * Stops any running animation or tracking. `callback` is invoked with the
   * final value after stopping the animation, which is useful for updating
   * state to match the animation position with layout.
   *
   * See https://reactnative.dev/docs/animatedvalue#stopanimation
   */
  stopAnimation(callback) {
    this.stopTracking(), this._animation && this._animation.stop(), this._animation = null, callback && (this.__isNative ? NativeAnimatedAPI.getValue(this.__getNativeTag(), callback) : callback(this.__getValue()));
  }
  /**
   * Stops any animation and resets the value to its original.
   *
   * See https://reactnative.dev/docs/animatedvalue#resetanimation
   */
  resetAnimation(callback) {
    this.stopAnimation(callback), this._value = this._startingValue, this.__isNative && NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), this._startingValue);
  }
  __onAnimatedValueUpdateReceived(value) {
    this._updateValue(
      value,
      !1
      /*flush*/
    );
  }
  /**
   * Interpolates the value before updating the property, e.g. mapping 0-1 to
   * 0-10.
   */
  interpolate(config) {
    return new import_AnimatedInterpolation.default(this, config);
  }
  /**
   * Typically only used internally, but could be used by a custom Animation
   * class.
   *
   * See https://reactnative.dev/docs/animatedvalue#animate
   */
  animate(animation, callback) {
    var handle = null;
    animation.__isInteraction && (handle = import_react_native_web_internals.InteractionManager.createInteractionHandle());
    var previousAnimation = this._animation;
    this._animation && this._animation.stop(), this._animation = animation, animation.start(
      this._value,
      (value) => {
        this._updateValue(
          value,
          !0
          /* flush */
        );
      },
      (result) => {
        this._animation = null, handle !== null && import_react_native_web_internals.InteractionManager.clearInteractionHandle(handle), callback && callback(result);
      },
      previousAnimation,
      this
    );
  }
  /**
   * Typically only used internally.
   */
  stopTracking() {
    this._tracking && this._tracking.__detach(), this._tracking = null;
  }
  /**
   * Typically only used internally.
   */
  track(tracking) {
    this.stopTracking(), this._tracking = tracking, this._tracking && this._tracking.update();
  }
  _updateValue(value, flush) {
    if (value === void 0)
      throw new Error("AnimatedValue: Attempting to set value to undefined");
    this._value = value, flush && _flush(this), super.__callListeners(this.__getValue());
  }
  __getNativeConfig() {
    return {
      type: "value",
      value: this._value,
      offset: this._offset
    };
  }
}
var AnimatedValue_default = AnimatedValue;
//# sourceMappingURL=AnimatedValue.js.map
