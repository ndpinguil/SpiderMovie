"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var AnimatedInterpolation_exports = {};
__export(AnimatedInterpolation_exports, {
  default: () => AnimatedInterpolation_default
});
module.exports = __toCommonJS(AnimatedInterpolation_exports);
var import_normalize_css_color = __toESM(require("@tamagui/normalize-css-color")), import_react_native_web_internals = require("react-native-web-internals"), import_NativeAnimatedHelper = __toESM(require("../NativeAnimatedHelper")), import_AnimatedWithChildren = __toESM(require("./AnimatedWithChildren")), __DEV__ = process.env.NODE_ENV !== "production", linear = (t) => t;
function createInterpolation(config) {
  if (config.outputRange && typeof config.outputRange[0] == "string")
    return createInterpolationFromStringOutputRange(config);
  var outputRange = config.outputRange, inputRange = config.inputRange;
  __DEV__ && (checkInfiniteRange("outputRange", outputRange), checkInfiniteRange("inputRange", inputRange), checkValidInputRange(inputRange), (0, import_react_native_web_internals.invariant)(
    inputRange.length === outputRange.length,
    "inputRange (" + inputRange.length + ") and outputRange (" + outputRange.length + ") must have the same length"
  ));
  var easing = config.easing || linear, extrapolateLeft = "extend";
  config.extrapolateLeft !== void 0 ? extrapolateLeft = config.extrapolateLeft : config.extrapolate !== void 0 && (extrapolateLeft = config.extrapolate);
  var extrapolateRight = "extend";
  return config.extrapolateRight !== void 0 ? extrapolateRight = config.extrapolateRight : config.extrapolate !== void 0 && (extrapolateRight = config.extrapolate), (input) => {
    (0, import_react_native_web_internals.invariant)(
      typeof input == "number",
      "Cannot interpolation an input which is not a number"
    );
    var range = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range],
      inputRange[range + 1],
      outputRange[range],
      outputRange[range + 1],
      easing,
      extrapolateLeft,
      extrapolateRight
    );
  };
}
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
  var result = input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    extrapolateLeft === "clamp" && (result = inputMin);
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    extrapolateRight === "clamp" && (result = inputMax);
  }
  return outputMin === outputMax ? outputMin : inputMin === inputMax ? input <= inputMin ? outputMin : outputMax : (inputMin === -1 / 0 ? result = -result : inputMax === 1 / 0 ? result = result - inputMin : result = (result - inputMin) / (inputMax - inputMin), result = easing(result), outputMin === -1 / 0 ? result = -result : outputMax === 1 / 0 ? result = result + outputMin : result = result * (outputMax - outputMin) + outputMin, result);
}
function colorToRgba(input) {
  var normalizedColor = (0, import_normalize_css_color.default)(input);
  if (normalizedColor === null || typeof normalizedColor != "number")
    return input;
  normalizedColor = normalizedColor || 0;
  var r = (normalizedColor & 4278190080) >>> 24, g = (normalizedColor & 16711680) >>> 16, b = (normalizedColor & 65280) >>> 8, a = (normalizedColor & 255) / 255;
  return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
}
var stringShapeRegex = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;
function createInterpolationFromStringOutputRange(config) {
  var outputRange = config.outputRange;
  (0, import_react_native_web_internals.invariant)(outputRange.length >= 2, "Bad output range"), outputRange = outputRange.map(colorToRgba), checkPattern(outputRange);
  var outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
  outputRange.forEach((value) => {
    value.match(stringShapeRegex).forEach((number, i) => {
      outputRanges[i].push(+number);
    });
  });
  var interpolations = outputRange[0].match(stringShapeRegex).map((value, i) => createInterpolation({
    ...config,
    outputRange: outputRanges[i]
  })), shouldRound = isRgbOrRgba(outputRange[0]);
  return (input) => {
    var i = 0;
    return outputRange[0].replace(stringShapeRegex, () => {
      var val = +interpolations[i++](input);
      return shouldRound && (val = i < 4 ? Math.round(val) : Math.round(val * 1e3) / 1e3), String(val);
    });
  };
}
function isRgbOrRgba(range) {
  return typeof range == "string" && range.startsWith("rgb");
}
function checkPattern(arr) {
  for (var pattern = arr[0].replace(stringShapeRegex, ""), i = 1; i < arr.length; ++i)
    (0, import_react_native_web_internals.invariant)(
      pattern === arr[i].replace(stringShapeRegex, ""),
      "invalid pattern " + arr[0] + " and " + arr[i]
    );
}
function findRange(input, inputRange) {
  var i;
  for (i = 1; i < inputRange.length - 1 && !(inputRange[i] >= input); ++i)
    ;
  return i - 1;
}
function checkValidInputRange(arr) {
  (0, import_react_native_web_internals.invariant)(arr.length >= 2, "inputRange must have at least 2 elements");
  for (var message = "inputRange must be monotonically non-decreasing " + String(arr), i = 1; i < arr.length; ++i)
    (0, import_react_native_web_internals.invariant)(arr[i] >= arr[i - 1], message);
}
function checkInfiniteRange(name, arr) {
  (0, import_react_native_web_internals.invariant)(arr.length >= 2, name + " must have at least 2 elements"), (0, import_react_native_web_internals.invariant)(
    arr.length !== 2 || arr[0] !== -1 / 0 || arr[1] !== 1 / 0,
    /* $FlowFixMe[incompatible-type] (>=0.13.0) - In the addition expression
     * below this comment, one or both of the operands may be something that
     * doesn't cleanly convert to a string, like undefined, null, and object,
     * etc. If you really mean this implicit string conversion, you can do
     * something like String(myThing) */
    name + "cannot be ]-infinity;+infinity[ " + arr
  );
}
class AnimatedInterpolation extends import_AnimatedWithChildren.default {
  // Export for testing.
  constructor(parent, config) {
    super(), this._parent = parent, this._config = config, this._interpolation = createInterpolation(config);
  }
  __makeNative(platformConfig) {
    this._parent.__makeNative(platformConfig), super.__makeNative(platformConfig);
  }
  __getValue() {
    var parentValue = this._parent.__getValue();
    return (0, import_react_native_web_internals.invariant)(
      typeof parentValue == "number",
      "Cannot interpolate an input which is not a number."
    ), this._interpolation(parentValue);
  }
  interpolate(config) {
    return new AnimatedInterpolation(this, config);
  }
  __attach() {
    this._parent.__addChild(this);
  }
  __detach() {
    this._parent.__removeChild(this), super.__detach();
  }
  __transformDataType(range) {
    return range.map(import_NativeAnimatedHelper.default.transformDataType);
  }
  __getNativeConfig() {
    return __DEV__ && import_NativeAnimatedHelper.default.validateInterpolation(this._config), {
      inputRange: this._config.inputRange,
      // Only the `outputRange` can contain strings so we don't need to transform `inputRange` here
      outputRange: this.__transformDataType(this._config.outputRange),
      extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || "extend",
      extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || "extend",
      type: "interpolation"
    };
  }
}
AnimatedInterpolation.__createInterpolation = createInterpolation;
var AnimatedInterpolation_default = AnimatedInterpolation;
//# sourceMappingURL=AnimatedInterpolation.js.map
