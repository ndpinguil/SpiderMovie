var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var EventEmitter_exports = {};
__export(EventEmitter_exports, {
  default: () => EventEmitter_default
});
module.exports = __toCommonJS(EventEmitter_exports);
var import_react_native_web_internals = require("react-native-web-internals"), import_EmitterSubscription = __toESM(require("./_EmitterSubscription")), import_EventSubscriptionVendor = __toESM(require("./_EventSubscriptionVendor")), sparseFilterPredicate = () => !0;
class EventEmitter {
  /**
   * @constructor
   *
   * @param {EventSubscriptionVendor} subscriber - Optional subscriber instance
   *   to use. If omitted, a new subscriber will be created for the emitter.
   */
  constructor(subscriber = new import_EventSubscriptionVendor.default()) {
    this._subscriber = subscriber;
  }
  /**
   * Adds a listener to be invoked when events of the specified type are
   * emitted. An optional calling context may be provided. The data arguments
   * emitted will be passed to the listener function.
   *
   * TODO: Annotate the listener arg's type. This is tricky because listeners
   *       can be invoked with varargs.
   *
   * @param {string} eventType - Name of the event to listen to
   * @param {function} listener - Function to invoke when the specified event is
   *   emitted
   * @param {*} context - Optional context object to use when invoking the
   *   listener
   */
  addListener(eventType, listener, context) {
    return this._subscriber.addSubscription(
      eventType,
      new import_EmitterSubscription.default(this, this._subscriber, listener, context)
    );
  }
  /**
   * Removes all of the registered listeners, including those registered as
   * listener maps.
   *
   * @param {?string} eventType - Optional name of the event whose registered
   *   listeners to remove
   */
  removeAllListeners(eventType) {
    this._subscriber.removeAllSubscriptions(eventType);
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */
  removeSubscription(subscription) {
    (0, import_react_native_web_internals.invariant)(
      subscription.emitter === this,
      "Subscription does not belong to this emitter."
    ), this._subscriber.removeSubscription(subscription);
  }
  /**
   * Returns the number of listeners that are currently registered for the given
   * event.
   *
   * @param {string} eventType - Name of the event to query
   * @returns {number}
   */
  listenerCount(eventType) {
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    return subscriptions ? (
      // "callbackfn is called only for elements of the array which actually
      // exist; it is not called for missing elements of the array."
      // https://www.ecma-international.org/ecma-262/9.0/index.html#sec-array.prototype.filter
      subscriptions.filter(sparseFilterPredicate).length
    ) : 0;
  }
  /**
   * Emits an event of the given type with the given data. All handlers of that
   * particular type will be notified.
   *
   * @param {string} eventType - Name of the event to emit
   * @param {...*} Arbitrary arguments to be passed to each registered listener
   *
   * @example
   *   emitter.addListener('someEvent', function(message) {
   *     console.log(message);
   *   });
   *
   *   emitter.emit('someEvent', 'abc'); // logs 'abc'
   */
  emit(eventType) {
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    if (subscriptions) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        args[_key - 1] = arguments[_key];
      for (var i = 0, l = subscriptions.length; i < l; i++) {
        var subscription = subscriptions[i];
        subscription && subscription.listener && subscription.listener.apply(subscription.context, args);
      }
    }
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */
  removeListener(eventType, listener) {
    console.error(
      "EventEmitter.removeListener('" + eventType + "', ...): Method has been deprecated. Please instead use `remove()` on the subscription returned by `EventEmitter.addListener`."
    );
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    if (subscriptions)
      for (var i = 0, l = subscriptions.length; i < l; i++) {
        var subscription = subscriptions[i];
        subscription && subscription.listener === listener && subscription.remove();
      }
  }
}
var EventEmitter_default = EventEmitter;
//# sourceMappingURL=_EventEmitter.js.map
