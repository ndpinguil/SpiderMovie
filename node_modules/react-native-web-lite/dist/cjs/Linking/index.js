var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var Linking_exports = {};
__export(Linking_exports, {
  default: () => Linking_default
});
module.exports = __toCommonJS(Linking_exports);
var import_react_native_web_internals = require("react-native-web-internals");
const initialURL = import_react_native_web_internals.canUseDOM ? window.location.href : "";
class Linking {
  /**
   * An object mapping of event name
   * and all the callbacks subscribing to it
   */
  _eventCallbacks = {};
  _dispatchEvent(event, ...data) {
    const listeners = this._eventCallbacks[event];
    listeners != null && Array.isArray(listeners) && listeners.map((listener) => {
      listener(...data);
    });
  }
  /**
   * Adds a event listener for the specified event. The callback will be called when the
   * said event is dispatched.
   */
  addEventListener = (event, callback) => {
    if (!this._eventCallbacks[event]) {
      this._eventCallbacks[event] = [callback];
      return;
    }
    this._eventCallbacks[event].push(callback);
  };
  /**
   * Removes a previously added event listener for the specified event. The callback must
   * be the same object as the one passed to `addEventListener`.
   */
  removeEventListener = (event, callback) => {
    const filteredCallbacks = this._eventCallbacks[event].filter(
      (c) => c.toString() !== callback.toString()
    );
    this._eventCallbacks[event] = filteredCallbacks;
  };
  canOpenURL() {
    return Promise.resolve(!0);
  }
  getInitialURL() {
    return Promise.resolve(initialURL);
  }
  /**
   * Try to open the given url in a secure fashion. The method returns a Promise object.
   * If a target is passed (including undefined) that target will be used, otherwise '_blank'.
   * If the url opens, the promise is resolved. If not, the promise is rejected.
   * Dispatches the `onOpen` event if `url` is opened successfully.
   */
  openURL(url, target) {
    arguments.length === 1 && (target = "_blank");
    try {
      return open(url, target), this._dispatchEvent("onOpen", url), Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  }
  _validateURL(url) {
    (0, import_react_native_web_internals.invariant)(typeof url == "string", "Invalid URL: should be a string. Was: " + url), (0, import_react_native_web_internals.invariant)(url, "Invalid URL: cannot be empty");
  }
}
const open = (url, target) => {
  if (import_react_native_web_internals.canUseDOM) {
    const urlToOpen = new URL(url, window.location).toString();
    urlToOpen.indexOf("tel:") === 0 ? window.location = urlToOpen : window.open(urlToOpen, target, "noopener");
  }
};
var Linking_default = new Linking();
//# sourceMappingURL=index.js.map
