import _createForOfIteratorHelperLoose from "@babel/runtime/helpers/createForOfIteratorHelperLoose";
import {
  useLayoutEffect as _,
  startTransition,
  useCallback,
  useEffect,
  useMemo,
  useReducer,
  useRef
} from "react";
import useRefEffect from "../useRefEffect";
import { AnimatedEvent } from "./AnimatedEvent";
import NativeAnimatedHelper from "./NativeAnimatedHelper";
import AnimatedProps from "./nodes/AnimatedProps";
const useLayoutEffect = typeof window > "u" ? useEffect : _;
function useAnimatedProps(props) {
  var _useReducer = useReducer((count) => count + 1, 0), scheduleUpdate = _useReducer[1], onUpdateRef = useRef(null), node = useMemo(
    () => new AnimatedProps(
      props,
      () => onUpdateRef.current == null ? void 0 : onUpdateRef.current()
    ),
    [props]
  );
  useAnimatedPropsLifecycle(node);
  var refEffect = useCallback(
    (instance) => {
      node.setNativeView(instance), onUpdateRef.current = () => {
        startTransition(() => {
          scheduleUpdate();
        });
      };
      var target = getEventTarget(instance), events = [];
      for (var propName in props) {
        var propValue = props[propName];
        propValue instanceof AnimatedEvent && propValue.__isNative && (propValue.__attach(target, propName), events.push([propName, propValue]));
      }
      return () => {
        onUpdateRef.current = null;
        for (var _iterator = _createForOfIteratorHelperLoose(events), _step; !(_step = _iterator()).done; ) {
          var _step$value = _step.value, _propName = _step$value[0], _propValue = _step$value[1];
          _propValue.__detach(target, _propName);
        }
      };
    },
    [props, node]
  ), callbackRef = useRefEffect(refEffect);
  return [reduceAnimatedProps(node), callbackRef];
}
function reduceAnimatedProps(node) {
  return {
    ...node.__getValue(),
    collapsable: !1
  };
}
function useAnimatedPropsLifecycle(node) {
  var prevNodeRef = useRef(null), isUnmountingRef = useRef(!1);
  useEffect(() => {
    NativeAnimatedHelper.API.flushQueue();
  }), useLayoutEffect(() => (isUnmountingRef.current = !1, () => {
    isUnmountingRef.current = !0;
  }), []), useLayoutEffect(() => {
    if (node.__attach(), prevNodeRef.current != null) {
      var prevNode = prevNodeRef.current;
      prevNode.__restoreDefaultValues(), prevNode.__detach(), prevNodeRef.current = null;
    }
    return () => {
      isUnmountingRef.current ? node.__detach() : prevNodeRef.current = node;
    };
  }, [node]);
}
function getEventTarget(instance) {
  return typeof instance == "object" && typeof instance?.getScrollableNode == "function" ? instance.getScrollableNode() : instance;
}
export {
  useAnimatedProps as default
};
//# sourceMappingURL=useAnimatedProps.js.map
