import { Platform, invariant } from "react-native-web-internals";
import { ReactNativeFeatureFlags } from "../FeatureFlags";
import NativeEventEmitter from "../NativeEventEmitter/index";
import RCTDeviceEventEmitter from "../NativeEventEmitter/RCTDeviceEventEmitter";
import NativeAnimatedNonTurboModule from "./NativeAnimatedModule";
import NativeAnimatedTurboModule from "./NativeAnimatedTurboModule";
var NativeAnimatedModule = Platform.OS === "ios" && global.RN$Bridgeless === !0 ? NativeAnimatedTurboModule : NativeAnimatedNonTurboModule, __nativeAnimatedNodeTagCount = 1, __nativeAnimationIdCount = 1, nativeEventEmitter, waitingForQueuedOperations = /* @__PURE__ */ new Set(), queueOperations = !1, queue = [], singleOpQueue = [], useSingleOpBatching = !1;
Platform.OS === "android" && (NativeAnimatedModule != null && NativeAnimatedModule.queueAndExecuteBatchedOperations) && ReactNativeFeatureFlags.animatedShouldUseSingleOp();
var flushQueueTimeout = null, eventListenerGetValueCallbacks = {}, eventListenerAnimationFinishedCallbacks = {};
var nativeOps = useSingleOpBatching ? function() {
  var apis = [
    "createAnimatedNode",
    // 1
    "updateAnimatedNodeConfig",
    // 2
    "getValue",
    // 3
    "startListeningToAnimatedNodeValue",
    // 4
    "stopListeningToAnimatedNodeValue",
    // 5
    "connectAnimatedNodes",
    // 6
    "disconnectAnimatedNodes",
    // 7
    "startAnimatingNode",
    // 8
    "stopAnimation",
    // 9
    "setAnimatedNodeValue",
    // 10
    "setAnimatedNodeOffset",
    // 11
    "flattenAnimatedNodeOffset",
    // 12
    "extractAnimatedNodeOffset",
    // 13
    "connectAnimatedNodeToView",
    // 14
    "disconnectAnimatedNodeFromView",
    // 15
    "restoreDefaultValues",
    // 16
    "dropAnimatedNode",
    // 17
    "addAnimatedEventToView",
    // 18
    "removeAnimatedEventFromView",
    // 19
    "addListener",
    // 20
    "removeListener"
    // 21
  ];
  return apis.reduce((acc, functionName, i) => (acc[functionName] = i + 1, acc), {});
}() : NativeAnimatedModule, API = {
  getValue: function(tag, saveValueCallback) {
    invariant(nativeOps, "Native animated module is not available"), useSingleOpBatching ? (saveValueCallback && (eventListenerGetValueCallbacks[tag] = saveValueCallback), API.queueOperation(nativeOps.getValue, tag)) : API.queueOperation(nativeOps.getValue, tag, saveValueCallback);
  },
  setWaitingForIdentifier: function(id) {
    waitingForQueuedOperations.add(id), queueOperations = !0, ReactNativeFeatureFlags.animatedShouldDebounceQueueFlush() && flushQueueTimeout && clearTimeout(flushQueueTimeout);
  },
  unsetWaitingForIdentifier: function(id) {
    waitingForQueuedOperations.delete(id), waitingForQueuedOperations.size === 0 && (queueOperations = !1, API.disableQueue());
  },
  disableQueue: function() {
    if (invariant(nativeOps, "Native animated module is not available"), ReactNativeFeatureFlags.animatedShouldDebounceQueueFlush()) {
      var prevTimeout = flushQueueTimeout;
      clearImmediate(prevTimeout), flushQueueTimeout = setImmediate(API.flushQueue);
    } else
      API.flushQueue();
  },
  flushQueue: function() {
  },
  queueOperation: function(fn) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      args[_key - 1] = arguments[_key];
    if (useSingleOpBatching) {
      singleOpQueue.push(fn, ...args);
      return;
    }
    queueOperations || queue.length !== 0 ? queue.push(() => fn(...args)) : fn(...args);
  },
  createAnimatedNode: function(tag, config) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.createAnimatedNode, tag, config);
  },
  updateAnimatedNodeConfig: function(tag, config) {
    invariant(nativeOps, "Native animated module is not available");
  },
  startListeningToAnimatedNodeValue: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.startListeningToAnimatedNodeValue, tag);
  },
  stopListeningToAnimatedNodeValue: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.stopListeningToAnimatedNodeValue, tag);
  },
  connectAnimatedNodes: function(parentTag, childTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.connectAnimatedNodes, parentTag, childTag);
  },
  disconnectAnimatedNodes: function(parentTag, childTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.disconnectAnimatedNodes, parentTag, childTag);
  },
  startAnimatingNode: function(animationId, nodeTag, config, endCallback) {
    invariant(nativeOps, "Native animated module is not available"), useSingleOpBatching ? (endCallback && (eventListenerAnimationFinishedCallbacks[animationId] = endCallback), API.queueOperation(nativeOps.startAnimatingNode, animationId, nodeTag, config)) : API.queueOperation(
      nativeOps.startAnimatingNode,
      animationId,
      nodeTag,
      config,
      endCallback
    );
  },
  stopAnimation: function(animationId) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.stopAnimation, animationId);
  },
  setAnimatedNodeValue: function(nodeTag, value) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.setAnimatedNodeValue, nodeTag, value);
  },
  setAnimatedNodeOffset: function(nodeTag, offset) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.setAnimatedNodeOffset, nodeTag, offset);
  },
  flattenAnimatedNodeOffset: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.flattenAnimatedNodeOffset, nodeTag);
  },
  extractAnimatedNodeOffset: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.extractAnimatedNodeOffset, nodeTag);
  },
  connectAnimatedNodeToView: function(nodeTag, viewTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.connectAnimatedNodeToView, nodeTag, viewTag);
  },
  disconnectAnimatedNodeFromView: function(nodeTag, viewTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.disconnectAnimatedNodeFromView, nodeTag, viewTag);
  },
  restoreDefaultValues: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), nativeOps.restoreDefaultValues != null && API.queueOperation(nativeOps.restoreDefaultValues, nodeTag);
  },
  dropAnimatedNode: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.dropAnimatedNode, tag);
  },
  addAnimatedEventToView: function(viewTag, eventName, eventMapping) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.addAnimatedEventToView, viewTag, eventName, eventMapping);
  },
  removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(
      nativeOps.removeAnimatedEventFromView,
      viewTag,
      eventName,
      animatedNodeTag
    );
  }
};
var SUPPORTED_COLOR_STYLES = {
  backgroundColor: !0,
  borderBottomColor: !0,
  borderColor: !0,
  borderEndColor: !0,
  borderLeftColor: !0,
  borderRightColor: !0,
  borderStartColor: !0,
  borderTopColor: !0,
  color: !0,
  tintColor: !0
}, SUPPORTED_STYLES = {
  ...SUPPORTED_COLOR_STYLES,
  borderBottomEndRadius: !0,
  borderBottomLeftRadius: !0,
  borderBottomRightRadius: !0,
  borderBottomStartRadius: !0,
  borderRadius: !0,
  borderTopEndRadius: !0,
  borderTopLeftRadius: !0,
  borderTopRightRadius: !0,
  borderTopStartRadius: !0,
  elevation: !0,
  opacity: !0,
  transform: !0,
  zIndex: !0,
  /* ios styles */
  shadowOpacity: !0,
  shadowRadius: !0,
  /* legacy android transform properties */
  scaleX: !0,
  scaleY: !0,
  translateX: !0,
  translateY: !0
}, SUPPORTED_TRANSFORMS = {
  translateX: !0,
  translateY: !0,
  scale: !0,
  scaleX: !0,
  scaleY: !0,
  rotate: !0,
  rotateX: !0,
  rotateY: !0,
  rotateZ: !0,
  perspective: !0
}, SUPPORTED_INTERPOLATION_PARAMS = {
  inputRange: !0,
  outputRange: !0,
  extrapolate: !0,
  extrapolateRight: !0,
  extrapolateLeft: !0
};
function addWhitelistedStyleProp(prop) {
  SUPPORTED_STYLES[prop] = !0;
}
function addWhitelistedTransformProp(prop) {
  SUPPORTED_TRANSFORMS[prop] = !0;
}
function addWhitelistedInterpolationParam(param) {
  SUPPORTED_INTERPOLATION_PARAMS[param] = !0;
}
function isSupportedColorStyleProp(prop) {
  return SUPPORTED_COLOR_STYLES.hasOwnProperty(prop);
}
function isSupportedStyleProp(prop) {
  return SUPPORTED_STYLES.hasOwnProperty(prop);
}
function isSupportedTransformProp(prop) {
  return SUPPORTED_TRANSFORMS.hasOwnProperty(prop);
}
function isSupportedInterpolationParam(param) {
  return SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(param);
}
function validateTransform(configs) {
  configs.forEach((config) => {
    if (!isSupportedTransformProp(config.property))
      throw new Error(
        "Property '" + config.property + "' is not supported by native animated module"
      );
  });
}
function validateStyles(styles) {
  for (var _key2 in styles)
    if (!isSupportedStyleProp(_key2))
      throw new Error(
        "Style property '" + _key2 + "' is not supported by native animated module"
      );
}
function validateInterpolation(config) {
  for (var _key3 in config)
    if (!isSupportedInterpolationParam(_key3))
      throw new Error(
        "Interpolation property '" + _key3 + "' is not supported by native animated module"
      );
}
function generateNewNodeTag() {
  return __nativeAnimatedNodeTagCount++;
}
function generateNewAnimationId() {
  return __nativeAnimationIdCount++;
}
function assertNativeAnimatedModule() {
  invariant(NativeAnimatedModule, "Native animated module is not available");
}
var _warnedMissingNativeAnimated = !1;
function shouldUseNativeDriver(config) {
  return config.useNativeDriver == null && console.warn(
    "Animated: `useNativeDriver` was not specified. This is a required option and must be explicitly set to `true` or `false`"
  ), config.useNativeDriver === !0 && !NativeAnimatedModule ? (_warnedMissingNativeAnimated || (console.warn(
    "Animated: `useNativeDriver` is not supported because the native animated module is missing. Falling back to JS-based animation. To resolve this, add `RCTAnimation` module to this app, or remove `useNativeDriver`. Make sure to run `bundle exec pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md"
  ), _warnedMissingNativeAnimated = !0), !1) : config.useNativeDriver || !1;
}
function transformDataType(value) {
  if (typeof value != "string")
    return value;
  if (/deg$/.test(value)) {
    var degrees = parseFloat(value) || 0, radians = degrees * Math.PI / 180;
    return radians;
  } else
    return value;
}
var NativeAnimatedHelper_default = {
  API,
  isSupportedColorStyleProp,
  isSupportedStyleProp,
  isSupportedTransformProp,
  isSupportedInterpolationParam,
  addWhitelistedStyleProp,
  addWhitelistedTransformProp,
  addWhitelistedInterpolationParam,
  validateStyles,
  validateTransform,
  validateInterpolation,
  generateNewNodeTag,
  generateNewAnimationId,
  assertNativeAnimatedModule,
  shouldUseNativeDriver,
  transformDataType,
  // $FlowExpectedError[unsafe-getters-setters] - unsafe getter lint suppresion
  // $FlowExpectedError[missing-type-arg] - unsafe getter lint suppresion
  get nativeEventEmitter() {
    return nativeEventEmitter || (nativeEventEmitter = new NativeEventEmitter(
      // T88715063: NativeEventEmitter only used this parameter on iOS. Now it uses it on all platforms, so this code was modified automatically to preserve its behavior
      // If you want to use the native module on other platforms, please remove this condition and test its behavior
      Platform.OS !== "ios" ? null : NativeAnimatedModule
    )), nativeEventEmitter;
  }
};
export {
  API,
  addWhitelistedInterpolationParam,
  addWhitelistedStyleProp,
  addWhitelistedTransformProp,
  assertNativeAnimatedModule,
  NativeAnimatedHelper_default as default,
  generateNewAnimationId,
  generateNewNodeTag,
  isSupportedColorStyleProp,
  isSupportedInterpolationParam,
  isSupportedStyleProp,
  isSupportedTransformProp,
  shouldUseNativeDriver,
  transformDataType,
  validateInterpolation,
  validateStyles,
  validateTransform
};
//# sourceMappingURL=NativeAnimatedHelper.js.map
