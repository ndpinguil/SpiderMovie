import { AnimatedEvent, attachNativeEvent } from "./AnimatedEvent";
import DecayAnimation from "./animations/DecayAnimation";
import SpringAnimation from "./animations/SpringAnimation";
import TimingAnimation from "./animations/TimingAnimation";
import createAnimatedComponent from "./createAnimatedComponent";
import AnimatedAddition from "./nodes/AnimatedAddition";
import AnimatedColor from "./nodes/AnimatedColor";
import AnimatedDiffClamp from "./nodes/AnimatedDiffClamp";
import AnimatedDivision from "./nodes/AnimatedDivision";
import AnimatedInterpolation from "./nodes/AnimatedInterpolation";
import AnimatedModulo from "./nodes/AnimatedModulo";
import AnimatedMultiplication from "./nodes/AnimatedMultiplication";
import AnimatedNode from "./nodes/AnimatedNode";
import AnimatedSubtraction from "./nodes/AnimatedSubtraction";
import AnimatedTracking from "./nodes/AnimatedTracking";
import AnimatedValue from "./nodes/AnimatedValue";
import AnimatedValueXY from "./nodes/AnimatedValueXY";
var add = function(a, b) {
  return new AnimatedAddition(a, b);
}, subtract = function(a, b) {
  return new AnimatedSubtraction(a, b);
}, divide = function(a, b) {
  return new AnimatedDivision(a, b);
}, multiply = function(a, b) {
  return new AnimatedMultiplication(a, b);
}, modulo = function(a, modulus) {
  return new AnimatedModulo(a, modulus);
}, diffClamp = function(a, min, max) {
  return new AnimatedDiffClamp(a, min, max);
}, _combineCallbacks = function(callback, config) {
  return callback && config.onComplete ? function() {
    config.onComplete && config.onComplete(...arguments), callback && callback(...arguments);
  } : callback || config.onComplete;
}, maybeVectorAnim = function(value, config, anim) {
  if (value instanceof AnimatedValueXY) {
    var configX = { ...config }, configY = { ...config };
    for (var key in config) {
      var _config$key = config[key], x = _config$key.x, y = _config$key.y;
      x !== void 0 && y !== void 0 && (configX[key] = x, configY[key] = y);
    }
    var aX = anim(value.x, configX), aY = anim(value.y, configY);
    return parallel([aX, aY], {
      stopTogether: !1
    });
  } else if (value instanceof AnimatedColor) {
    var configR = { ...config }, configG = { ...config }, configB = { ...config }, configA = { ...config };
    for (var _key in config) {
      var _config$_key = config[_key], r = _config$_key.r, g = _config$_key.g, b = _config$_key.b, a = _config$_key.a;
      r !== void 0 && g !== void 0 && b !== void 0 && a !== void 0 && (configR[_key] = r, configG[_key] = g, configB[_key] = b, configA[_key] = a);
    }
    var aR = anim(value.r, configR), aG = anim(value.g, configG), aB = anim(value.b, configB), aA = anim(value.a, configA);
    return parallel([aR, aG, aB, aA], {
      stopTogether: !1
    });
  }
  return null;
}, spring = function spring2(value, config) {
  var _start = function(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue, singleConfig = configuration;
    singleValue.stopTracking(), configuration.toValue instanceof AnimatedNode ? singleValue.track(
      new AnimatedTracking(
        singleValue,
        configuration.toValue,
        SpringAnimation,
        singleConfig,
        callback
      )
    ) : singleValue.animate(new SpringAnimation(singleConfig), callback);
  };
  return maybeVectorAnim(value, config, spring2) || {
    start: function(callback) {
      _start(value, config, callback);
    },
    stop: function() {
      value.stopAnimation();
    },
    reset: function() {
      value.resetAnimation();
    },
    _startNativeLoop: function(iterations) {
      var singleConfig = {
        ...config,
        iterations
      };
      _start(value, singleConfig);
    },
    _isUsingNativeDriver: function() {
      return config.useNativeDriver || !1;
    }
  };
}, timing = function timing2(value, config) {
  var _start2 = function(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue, singleConfig = configuration;
    singleValue.stopTracking(), configuration.toValue instanceof AnimatedNode ? singleValue.track(
      new AnimatedTracking(
        singleValue,
        configuration.toValue,
        TimingAnimation,
        singleConfig,
        callback
      )
    ) : singleValue.animate(new TimingAnimation(singleConfig), callback);
  };
  return maybeVectorAnim(value, config, timing2) || {
    start: function(callback) {
      _start2(value, config, callback);
    },
    stop: function() {
      value.stopAnimation();
    },
    reset: function() {
      value.resetAnimation();
    },
    _startNativeLoop: function(iterations) {
      var singleConfig = {
        ...config,
        iterations
      };
      _start2(value, singleConfig);
    },
    _isUsingNativeDriver: function() {
      return config.useNativeDriver || !1;
    }
  };
}, decay = function decay2(value, config) {
  var _start3 = function(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue, singleConfig = configuration;
    singleValue.stopTracking(), singleValue.animate(new DecayAnimation(singleConfig), callback);
  };
  return maybeVectorAnim(value, config, decay2) || {
    start: function(callback) {
      _start3(value, config, callback);
    },
    stop: function() {
      value.stopAnimation();
    },
    reset: function() {
      value.resetAnimation();
    },
    _startNativeLoop: function(iterations) {
      var singleConfig = {
        ...config,
        iterations
      };
      _start3(value, singleConfig);
    },
    _isUsingNativeDriver: function() {
      return config.useNativeDriver || !1;
    }
  };
}, sequence = function(animations) {
  var current = 0;
  return {
    start: function(callback) {
      var onComplete = function onComplete2(result) {
        if (!result.finished) {
          callback && callback(result);
          return;
        }
        if (current++, current === animations.length) {
          callback && callback(result);
          return;
        }
        animations[current].start(onComplete2);
      };
      animations.length === 0 ? callback && callback({
        finished: !0
      }) : animations[current].start(onComplete);
    },
    stop: function() {
      current < animations.length && animations[current].stop();
    },
    reset: function() {
      animations.forEach((animation, idx) => {
        idx <= current && animation.reset();
      }), current = 0;
    },
    _startNativeLoop: function() {
      throw new Error(
        "Loops run using the native driver cannot contain Animated.sequence animations"
      );
    },
    _isUsingNativeDriver: function() {
      return !1;
    }
  };
}, parallel = function(animations, config) {
  var doneCount = 0, hasEnded = {}, stopTogether = !(config && config.stopTogether === !1), result = {
    start: function(callback) {
      if (doneCount === animations.length) {
        callback && callback({
          finished: !0
        });
        return;
      }
      animations.forEach((animation, idx) => {
        var cb = function(endResult) {
          if (hasEnded[idx] = !0, doneCount++, doneCount === animations.length) {
            doneCount = 0, callback && callback(endResult);
            return;
          }
          !endResult.finished && stopTogether && result.stop();
        };
        animation ? animation.start(cb) : cb({
          finished: !0
        });
      });
    },
    stop: function() {
      animations.forEach((animation, idx) => {
        !hasEnded[idx] && animation.stop(), hasEnded[idx] = !0;
      });
    },
    reset: function() {
      animations.forEach((animation, idx) => {
        animation.reset(), hasEnded[idx] = !1, doneCount = 0;
      });
    },
    _startNativeLoop: function() {
      throw new Error(
        "Loops run using the native driver cannot contain Animated.parallel animations"
      );
    },
    _isUsingNativeDriver: function() {
      return !1;
    }
  };
  return result;
}, delay = function(time) {
  return timing(new AnimatedValue(0), {
    toValue: 0,
    delay: time,
    duration: 0,
    useNativeDriver: !1
  });
}, stagger = function(time, animations) {
  return parallel(
    animations.map((animation, i) => sequence([delay(time * i), animation]))
  );
}, loop = function(animation, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$iterations = _ref.iterations, iterations = _ref$iterations === void 0 ? -1 : _ref$iterations, _ref$resetBeforeItera = _ref.resetBeforeIteration, resetBeforeIteration = _ref$resetBeforeItera === void 0 ? !0 : _ref$resetBeforeItera, isFinished = !1, iterationsSoFar = 0;
  return {
    start: function(callback) {
      var restart = function restart2(result) {
        result === void 0 && (result = {
          finished: !0
        }), isFinished || iterationsSoFar === iterations || result.finished === !1 ? callback && callback(result) : (iterationsSoFar++, resetBeforeIteration && animation.reset(), animation.start(restart2));
      };
      !animation || iterations === 0 ? callback && callback({
        finished: !0
      }) : animation._isUsingNativeDriver() ? animation._startNativeLoop(iterations) : restart();
    },
    stop: function() {
      isFinished = !0, animation.stop();
    },
    reset: function() {
      iterationsSoFar = 0, isFinished = !1, animation.reset();
    },
    _startNativeLoop: function() {
      throw new Error(
        "Loops run using the native driver cannot contain Animated.loop animations"
      );
    },
    _isUsingNativeDriver: function() {
      return animation._isUsingNativeDriver();
    }
  };
};
function forkEvent(event3, listener) {
  return event3 ? event3 instanceof AnimatedEvent ? (event3.__addListener(listener), event3) : function() {
    typeof event3 == "function" && event3(...arguments), listener(...arguments);
  } : listener;
}
function unforkEvent(event3, listener) {
  event3 && event3 instanceof AnimatedEvent && event3.__removeListener(listener);
}
var event = function(argMapping, config) {
  var animatedEvent = new AnimatedEvent(argMapping, config);
  return animatedEvent.__isNative ? animatedEvent : animatedEvent.__getHandler();
}, AnimatedImplementation_default = {
  /**
   * Standard value class for driving animations.  Typically initialized with
   * `new Animated.Value(0);`
   *
   * See https://reactnative.dev/docs/animated#value
   */
  Value: AnimatedValue,
  /**
   * 2D value class for driving 2D animations, such as pan gestures.
   *
   * See https://reactnative.dev/docs/animatedvaluexy
   */
  ValueXY: AnimatedValueXY,
  /**
   * Value class for driving color animations.
   */
  Color: AnimatedColor,
  /**
   * Exported to use the Interpolation type in flow.
   *
   * See https://reactnative.dev/docs/animated#interpolation
   */
  Interpolation: AnimatedInterpolation,
  /**
   * Exported for ease of type checking. All animated values derive from this
   * class.
   *
   * See https://reactnative.dev/docs/animated#node
   */
  Node: AnimatedNode,
  /**
   * Animates a value from an initial velocity to zero based on a decay
   * coefficient.
   *
   * See https://reactnative.dev/docs/animated#decay
   */
  decay,
  /**
   * Animates a value along a timed easing curve. The Easing module has tons of
   * predefined curves, or you can use your own function.
   *
   * See https://reactnative.dev/docs/animated#timing
   */
  timing,
  /**
   * Animates a value according to an analytical spring model based on
   * damped harmonic oscillation.
   *
   * See https://reactnative.dev/docs/animated#spring
   */
  spring,
  /**
   * Creates a new Animated value composed from two Animated values added
   * together.
   *
   * See https://reactnative.dev/docs/animated#add
   */
  add,
  /**
   * Creates a new Animated value composed by subtracting the second Animated
   * value from the first Animated value.
   *
   * See https://reactnative.dev/docs/animated#subtract
   */
  subtract,
  /**
   * Creates a new Animated value composed by dividing the first Animated value
   * by the second Animated value.
   *
   * See https://reactnative.dev/docs/animated#divide
   */
  divide,
  /**
   * Creates a new Animated value composed from two Animated values multiplied
   * together.
   *
   * See https://reactnative.dev/docs/animated#multiply
   */
  multiply,
  /**
   * Creates a new Animated value that is the (non-negative) modulo of the
   * provided Animated value.
   *
   * See https://reactnative.dev/docs/animated#modulo
   */
  modulo,
  /**
   * Create a new Animated value that is limited between 2 values. It uses the
   * difference between the last value so even if the value is far from the
   * bounds it will start changing when the value starts getting closer again.
   *
   * See https://reactnative.dev/docs/animated#diffclamp
   */
  diffClamp,
  /**
   * Starts an animation after the given delay.
   *
   * See https://reactnative.dev/docs/animated#delay
   */
  delay,
  /**
   * Starts an array of animations in order, waiting for each to complete
   * before starting the next. If the current running animation is stopped, no
   * following animations will be started.
   *
   * See https://reactnative.dev/docs/animated#sequence
   */
  sequence,
  /**
   * Starts an array of animations all at the same time. By default, if one
   * of the animations is stopped, they will all be stopped. You can override
   * this with the `stopTogether` flag.
   *
   * See https://reactnative.dev/docs/animated#parallel
   */
  parallel,
  /**
   * Array of animations may run in parallel (overlap), but are started in
   * sequence with successive delays.  Nice for doing trailing effects.
   *
   * See https://reactnative.dev/docs/animated#stagger
   */
  stagger,
  /**
   * Loops a given animation continuously, so that each time it reaches the
   * end, it resets and begins again from the start.
   *
   * See https://reactnative.dev/docs/animated#loop
   */
  loop,
  /**
   * Takes an array of mappings and extracts values from each arg accordingly,
   * then calls `setValue` on the mapped outputs.
   *
   * See https://reactnative.dev/docs/animated#event
   */
  event,
  /**
   * Make any React component Animatable.  Used to create `Animated.View`, etc.
   *
   * See https://reactnative.dev/docs/animated#createanimatedcomponent
   */
  createAnimatedComponent,
  /**
   * Imperative API to attach an animated value to an event on a view. Prefer
   * using `Animated.event` with `useNativeDrive: true` if possible.
   *
   * See https://reactnative.dev/docs/animated#attachnativeevent
   */
  attachNativeEvent,
  /**
   * Advanced imperative API for snooping on animated events that are passed in
   * through props. Use values directly where possible.
   *
   * See https://reactnative.dev/docs/animated#forkevent
   */
  forkEvent,
  unforkEvent,
  /**
   * Expose Event class, so it can be used as a type for type checkers.
   */
  Event: AnimatedEvent
};
export {
  AnimatedImplementation_default as default
};
//# sourceMappingURL=AnimatedImplementation.js.map
