const TouchHistoryMath = {
  /**
   * This code is optimized and not intended to look beautiful. This allows
   * computing of touch centroids that have moved after `touchesChangedAfter`
   * timeStamp. You can compute the current centroid involving all touches
   * moves after `touchesChangedAfter`, or you can compute the previous
   * centroid of all touches that were moved after `touchesChangedAfter`.
   *
   * @param {TouchHistoryMath} touchHistory Standard Responder touch track
   * data.
   * @param {number} touchesChangedAfter timeStamp after which moved touches
   * are considered "actively moving" - not just "active".
   * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.
   * @param {boolean} ofCurrent Compute current centroid for actively moving
   * touches vs. previous centroid of now actively moving touches.
   * @return {number} value of centroid in specified dimension.
   */
  centroidDimension: function(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
    const touchBank = touchHistory.touchBank;
    let total = 0, count = 0;
    const oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;
    if (oneTouchData !== null)
      oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter && (total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY, count = 1);
    else
      for (let i = 0; i < touchBank.length; i++) {
        const touchTrack = touchBank[i];
        if (touchTrack != null && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
          let toAdd;
          ofCurrent && isXAxis ? toAdd = touchTrack.currentPageX : ofCurrent && !isXAxis ? toAdd = touchTrack.currentPageY : !ofCurrent && isXAxis ? toAdd = touchTrack.previousPageX : toAdd = touchTrack.previousPageY, total += toAdd, count++;
        }
      }
    return count > 0 ? total / count : TouchHistoryMath.noCentroid;
  },
  currentCentroidXOfTouchesChangedAfter: function(touchHistory, touchesChangedAfter) {
    return TouchHistoryMath.centroidDimension(
      touchHistory,
      touchesChangedAfter,
      !0,
      // isXAxis
      !0
      // ofCurrent
    );
  },
  currentCentroidYOfTouchesChangedAfter: function(touchHistory, touchesChangedAfter) {
    return TouchHistoryMath.centroidDimension(
      touchHistory,
      touchesChangedAfter,
      !1,
      // isXAxis
      !0
      // ofCurrent
    );
  },
  previousCentroidXOfTouchesChangedAfter: function(touchHistory, touchesChangedAfter) {
    return TouchHistoryMath.centroidDimension(
      touchHistory,
      touchesChangedAfter,
      !0,
      // isXAxis
      !1
      // ofCurrent
    );
  },
  previousCentroidYOfTouchesChangedAfter: function(touchHistory, touchesChangedAfter) {
    return TouchHistoryMath.centroidDimension(
      touchHistory,
      touchesChangedAfter,
      !1,
      // isXAxis
      !1
      // ofCurrent
    );
  },
  currentCentroidX: function(touchHistory) {
    return TouchHistoryMath.centroidDimension(
      touchHistory,
      0,
      // touchesChangedAfter
      !0,
      // isXAxis
      !0
      // ofCurrent
    );
  },
  currentCentroidY: function(touchHistory) {
    return TouchHistoryMath.centroidDimension(
      touchHistory,
      0,
      // touchesChangedAfter
      !1,
      // isXAxis
      !0
      // ofCurrent
    );
  },
  noCentroid: -1
};
var TouchHistoryMath_default = TouchHistoryMath;
export {
  TouchHistoryMath_default as default
};
//# sourceMappingURL=index.js.map
