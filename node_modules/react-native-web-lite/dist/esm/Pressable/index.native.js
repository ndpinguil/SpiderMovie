import { usePressEvents } from "@tamagui/react-native-use-pressable";
import * as React from "react";
import { forwardRef, memo, useMemo, useRef, useState } from "react";
import { StyleSheet } from "react-native-web-internals";
import { useHover, useMergeRefs } from "react-native-web-internals";
import View from "../View/index";
import { jsx } from "react/jsx-runtime";
function Pressable(props, forwardedRef) {
  const {
    children,
    delayLongPress,
    delayPressIn,
    delayPressOut,
    disabled,
    focusable,
    onBlur,
    onContextMenu,
    onFocus,
    onHoverIn,
    onHoverOut,
    onKeyDown,
    onLongPress,
    onPress,
    onPressMove,
    onPressIn,
    onPressOut,
    style,
    testOnly_hovered,
    testOnly_pressed,
    ...rest
  } = props, [hovered, setHovered] = useForceableState(testOnly_hovered === !0), [focused, setFocused] = useForceableState(!1), [pressed, setPressed] = useForceableState(testOnly_pressed === !0), hostRef = useRef(null), setRef = useMergeRefs(forwardedRef, hostRef), pressConfig = useMemo(
    () => ({
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      disabled,
      onLongPress,
      onPress,
      onPressChange: setPressed,
      onPressStart: onPressIn,
      onPressMove,
      onPressEnd: onPressOut
    }),
    [
      delayLongPress,
      delayPressIn,
      delayPressOut,
      disabled,
      onLongPress,
      onPress,
      onPressIn,
      onPressMove,
      onPressOut,
      setPressed
    ]
  ), pressEventHandlers = usePressEvents(hostRef, pressConfig), { onContextMenu: onContextMenuPress, onKeyDown: onKeyDownPress } = pressEventHandlers;
  useHover(hostRef, {
    contain: !0,
    disabled,
    onHoverChange: setHovered,
    onHoverStart: onHoverIn,
    onHoverEnd: onHoverOut
  });
  const interactionState = { hovered, focused, pressed }, blurHandler = React.useCallback(
    (e) => {
      disabled || e.nativeEvent.target === hostRef.current && (setFocused(!1), onBlur?.(e));
    },
    [disabled, hostRef, setFocused, onBlur]
  ), focusHandler = React.useCallback(
    (e) => {
      disabled || e.nativeEvent.target === hostRef.current && (setFocused(!0), onFocus?.(e));
    },
    [disabled, hostRef, setFocused, onFocus]
  ), contextMenuHandler = React.useCallback(
    (e) => {
      onContextMenuPress?.(e), onContextMenu?.(e);
    },
    [onContextMenu, onContextMenuPress]
  ), keyDownHandler = React.useCallback(
    (e) => {
      onKeyDownPress?.(e), onKeyDown?.(e);
    },
    [onKeyDown, onKeyDownPress]
  );
  return /* @__PURE__ */ jsx(
    View,
    {
      ...rest,
      ...pressEventHandlers,
      accessibilityDisabled: disabled,
      focusable: !disabled && focusable !== !1,
      onBlur: blurHandler,
      onContextMenu: contextMenuHandler,
      onFocus: focusHandler,
      onKeyDown: keyDownHandler,
      pointerEvents: disabled ? "none" : rest.pointerEvents,
      ref: setRef,
      style: [
        !disabled && styles.root,
        typeof style == "function" ? style(interactionState) : style
      ],
      children: typeof children == "function" ? children(interactionState) : children
    }
  );
}
function useForceableState(forced) {
  const [bool, setBool] = useState(!1);
  return [bool || forced, setBool];
}
const styles = StyleSheet.create({
  root: {
    cursor: "pointer",
    touchAction: "manipulation"
  }
}), MemoedPressable = memo(forwardRef(Pressable));
MemoedPressable.displayName = "Pressable";
var Pressable_default = MemoedPressable;
export {
  Pressable_default as default
};
//# sourceMappingURL=index.js.map
